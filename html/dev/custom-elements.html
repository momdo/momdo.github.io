<!DOCTYPE html><html class="split" lang="ja"><script src="https://html.spec.whatwg.org/link-fixup.js" defer=""></script><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"><title>HTML Standard, Edition for Web Developers日本語訳</title><meta content="#3c790a" name="theme-color"><link rel="stylesheet" href="https://resources.whatwg.org/standard-shared-with-dev.css" crossorigin=""><link rel="icon" href="https://resources.whatwg.org/logo.svg" crossorigin=""><link rel="stylesheet" href="https://html.spec.whatwg.org/dev/styles.css" crossorigin=""><script>
   function toggleStatus(div) {
     div.parentNode.classList.toggle('wrapped');
   }
   function setLinkFragment(link) {
     link.hash = location.hash;
   }
  </script><body>
  <script async="" src="./search.js"></script>
  
  
  
  <header id="head" class="head with-buttons"><a href="https://whatwg.org/" class="logo"><img width="100" alt="WHATWG" crossorigin="" src="https://resources.whatwg.org/logo.svg" height="100"></a><hgroup><h1><a rel="home" href="./dev" />HTML: The Living Standard</a></h1><h2 id="dev-edition-h2" class="no-num no-toc">Edition for Web Developers — Last Updated <span class="pubdate">30 June 2022</span></h2></hgroup>
   

   <div id="search"><input placeholder="Search. Press '/'" autocomplete="off" name="query" id="query" type="search"><ol id="results"></ol>
   </div>
  </header>

  

  

  

  
  

  
  

  

  <nav><a href="canvas.html">← 4.12.5 canvas要素</a> – <a href="./">目次</a> – <a href="semantics-other.html">4.14 専用要素なしの一般的語彙 →</a></nav><ol class="toc"><li><ol><li><a href="custom-elements.html#custom-elements"><span class="secno">4.13</span> カスタム要素</a><ol><li><a href="custom-elements.html#custom-elements-intro"><span class="secno">4.13.1</span> 導入</a><ol><li><a href="custom-elements.html#custom-elements-autonomous-example"><span class="secno">4.13.1.1</span> 自律カスタム要素の作成</a><li><a href="custom-elements.html#custom-elements-face-example"><span class="secno">4.13.1.2</span> フォームに関連付けられたカスタム要素の作成</a><li><a href="custom-elements.html#custom-elements-accessibility-example"><span class="secno">4.13.1.3</span> デフォルトでアクセシブルなロール、ステート、およびプロパティをもつカスタム要素を作成する</a><li><a href="custom-elements.html#custom-elements-customized-builtin-example"><span class="secno">4.13.1.4</span> カスタマイズされた組み込み要素の作成</a><li><a href="custom-elements.html#custom-elements-autonomous-drawbacks"><span class="secno">4.13.1.5</span> 自律カスタム要素の欠点</a><li><a href="custom-elements.html#custom-elements-upgrades-examples"><span class="secno">4.13.1.6</span> 作成後の要素のアップグレード</a></ol><li><a href="custom-elements.html#custom-element-conformance"><span class="secno">4.13.2</span> カスタム要素のコンストラクターと反応の要件</a><li><a href="custom-elements.html#custom-elements-core-concepts"><span class="secno">4.13.3</span> コアコンセプト</a><li><a href="custom-elements.html#custom-elements-api"><span class="secno">4.13.4</span> <code>CustomElementRegistry</code>インターフェイス</a><li><a href="custom-elements.html#custom-element-reactions"><span class="secno">4.13.5</span> カスタム要素応答</a><li><a href="custom-elements.html#element-internals"><span class="secno">4.13.6</span> 要素内部</a><ol><li><a href="custom-elements.html#shadow-root-access"><span class="secno">4.13.6.1</span> シャドウルートアクセス</a><li><a href="custom-elements.html#form-associated-custom-elements"><span class="secno">4.13.6.2</span> フォームに関連付けられたカスタム要素</a><li><a href="custom-elements.html#accessibility-semantics"><span class="secno">4.13.6.3</span> アクセシビリティセマンティックス</a></ol></ol></ol></ol><h3 id="custom-elements"><span class="secno">4.13</span> カスタム要素<a href="#custom-elements" class="self-link"></a></h3><div class="mdn-anno wrapped"><button onclick="toggleStatus(this)" class="mdn-anno-btn"><b title="Support in all current engines." class="all-engines-flag">✔</b><span>MDN</span></button><div class="feature"><p><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" title="One of the key features of the Web Components standard is the ability to create custom elements that encapsulate your functionality on an HTML page, rather than having to make do with a long, nested batch of elements that together provide a custom page feature. This article introduces the use of the Custom Elements API.">Using_custom_elements</a><p class="all-engines-text">Support in all current engines.<div class="support"><span class="firefox yes"><span>Firefox</span><span>63+</span></span><span class="safari yes"><span>Safari</span><span>10.1+</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera unknown"><span>Opera</span><span>?</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge unknown"><span>Edge (Legacy)</span><span>?</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android unknown"><span>Firefox Android</span><span>?</span></span><span class="safari_ios unknown"><span>Safari iOS</span><span>?</span></span><span class="chrome_android unknown"><span>Chrome Android</span><span>?</span></span><span class="webview_android unknown"><span>WebView Android</span><span>?</span></span><span class="samsunginternet_android unknown"><span>Samsung Internet</span><span>?</span></span><span class="opera_android unknown"><span>Opera Android</span><span>?</span></span></div></div></div>

  <h4 id="custom-elements-intro"><span class="secno">4.13.1</span> 導入<a href="#custom-elements-intro" class="self-link"></a></h4>

  

  <p><a href="#custom-element" id="custom-elements-intro:custom-element">カスタム要素</a>は、著者にフル機能のDOM要素を独自に構築する方法を提供する。スクリプティングなどで後に追加されたアプリケーション固有の動作を用いて、著者は文書内で非標準要素を常に使用することができるが、そのような要素は歴史的に不適合であり、あまり機能的ではなかった。カスタム要素を<a href="#element-definition" id="custom-elements-intro:element-definition">定義する</a>ことで、著者はパーサーに要素を適切に構築する方法、およびそのクラスの要素が変更にどのように反応すべきかを伝えることができる。</p>

  <p>カスタム要素は、（カスタム要素の定義のような）低レベルの著者に公開される拡張ポイントの言葉で、（HTMLの要素のような）既存のプラットフォームの機能を説明することによって、"プラットフォームを合理的に説明し"ようとするより大きな活動の一部である。現在、カスタム要素の能力には、機能的にも意味的にも多くの制限があり、HTMLの既存の要素の振る舞いを完全に説明することを妨げているが、我々は時が経つにつれこの隔たりが縮小することを望む。</p>

  <h5 id="custom-elements-autonomous-example"><span class="secno">4.13.1.1</span> 自律カスタム要素の作成<a href="#custom-elements-autonomous-example" class="self-link"></a></h5>

  

  <p><a href="#autonomous-custom-element" id="custom-elements-autonomous-example:autonomous-custom-element">自律カスタム要素</a>を作成する方法を説明するために、国旗の小さなアイコンのレンダリングをカプセル化するカスタム要素を定義してみよう。私たちの目標は、次のように使用できるようにすることである：</p>

  <pre><code class='html'><c- p>&lt;</c-><c- f>flag-icon</c-> <c- e>country</c-><c- o>=</c-><c- s>"nl"</c-><c- p>>&lt;/</c-><c- f>flag-icon</c-><c- p>></c-></code></pre>

  <p>これを行うには、まずカスタム要素のクラスを宣言し、<code>HTMLElement</code>を拡張する：</p>

  <pre><code class='js'><c- a>class</c-> FlagIcon <c- k>extends</c-> HTMLElement <c- p>{</c->
  constructor<c- p>()</c-> <c- p>{</c->
    <c- k>super</c-><c- p>();</c->
    <c- k>this</c-><c- p>.</c->_countryCode <c- o>=</c-> <c- kc>null</c-><c- p>;</c->
  <c- p>}</c->

  <c- k>static</c-> observedAttributes <c- o>=</c-> <c- p>[</c-><c- u>"country"</c-><c- p>];</c->

  attributeChangedCallback<c- p>(</c->name<c- p>,</c-> oldValue<c- p>,</c-> newValue<c- p>)</c-> <c- p>{</c->
    <c- c1>// name will always be "country" due to observedAttributes</c->
    <c- k>this</c-><c- p>.</c->_countryCode <c- o>=</c-> newValue<c- p>;</c->
    <c- k>this</c-><c- p>.</c->_updateRendering<c- p>();</c->
  <c- p>}</c->
  connectedCallback<c- p>()</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->_updateRendering<c- p>();</c->
  <c- p>}</c->

  get country<c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- k>this</c-><c- p>.</c->_countryCode<c- p>;</c->
  <c- p>}</c->
  set country<c- p>(</c->v<c- p>)</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->setAttribute<c- p>(</c-><c- u>"country"</c-><c- p>,</c-> v<c- p>);</c->
  <c- p>}</c->

  _updateRendering<c- p>()</c-> <c- p>{</c->
    <c- c1>// Left as an exercise for the reader. But, you'll probably want to</c->
    <c- c1>// check this.ownerDocument.defaultView to see if we've been</c->
    <c- c1>// inserted into a document with a browsing context, and avoid</c->
    <c- c1>// doing any work if not.</c->
  <c- p>}</c->
<c- p>}</c-></code></pre>

  <p>次に、要素を定義するために次のクラスを使用して必要がある：</p>

  <pre><code class='js'>customElements<c- p>.</c->define<c- p>(</c-><c- u>"flag-icon"</c-><c- p>,</c-> FlagIcon<c- p>);</c-></code></pre>

  <p>この時点で、上記のコードは動作する。<code>flag-icon</code>タグを見るたびに、パーサーは<code>FlagIcon</code>クラスの新しいインスタンスを作成し、要素の内部状態を設定し、レンダリングを更新するために使用する（適切な場合）、新しい<code>country</code>属性についてコードに伝える。</p>

  <p>DOM APIを使用して<code>flag-icon</code>要素を作成することもできる：</p>

  <pre><code class='js'><c- a>const</c-> flagIcon <c- o>=</c-> document<c- p>.</c->createElement<c- p>(</c-><c- u>"flag-icon"</c-><c- p>)</c->
flagIcon<c- p>.</c->country <c- o>=</c-> <c- u>"jp"</c->
document<c- p>.</c->body<c- p>.</c->appendChild<c- p>(</c->flagIcon<c- p>)</c-></code></pre>

  <p>最後に、<a href="#custom-element-constructor" id="custom-elements-autonomous-example:custom-element-constructor">カスタム要素コンストラクター</a>自体を使用することもできる。つまり、上記のコードは次のコードと同じである：</p>

  <pre><code class='js'><c- a>const</c-> flagIcon <c- o>=</c-> <c- k>new</c-> FlagIcon<c- p>()</c->
flagIcon<c- p>.</c->country <c- o>=</c-> <c- u>"jp"</c->
document<c- p>.</c->body<c- p>.</c->appendChild<c- p>(</c->flagIcon<c- p>)</c-></code></pre>

  <h5 id="custom-elements-face-example"><span class="secno">4.13.1.2</span> フォームに関連付けられたカスタム要素の作成<a href="#custom-elements-face-example" class="self-link"></a></h5>

  

  <p>trueの値を持つ静的な<code>formAssociated</code>プロパティを追加すると、<a href="#autonomous-custom-element" id="custom-elements-face-example:autonomous-custom-element">自律カスタム要素</a>が<a href="#form-associated-custom-element" id="custom-elements-face-example:form-associated-custom-element">フォーム関連カスタム要素</a>になる。<code>ElementInternals</code>インターフェイスは、フォームコントロール要素に共通の関数およびプロパティを実装するのに役立つ。</p>

  <pre><code class='js'><c- a>class</c-> MyCheckbox <c- k>extends</c-> HTMLElement <c- p>{</c->
  <c- k>static</c-> formAssociated <c- o>=</c-> <c- kc>true</c-><c- p>;</c->
  <c- k>static</c-> observedAttributes <c- o>=</c-> <c- p>[</c-><c- t>'checked'</c-><c- p>];</c->

  constructor<c- p>()</c-> <c- p>{</c->
    <c- k>super</c-><c- p>();</c->
    <c- k>this</c-><c- p>.</c->_internals <c- o>=</c-> <c- k>this</c-><c- p>.</c->attachInternals<c- p>();</c->
    <c- k>this</c-><c- p>.</c->addEventListener<c- p>(</c-><c- t>'click'</c-><c- p>,</c-> <c- k>this</c-><c- p>.</c->_onClick<c- p>.</c->bind<c- p>(</c-><c- k>this</c-><c- p>));</c->
  <c- p>}</c->

  get form<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->form<c- p>;</c-> <c- p>}</c->
  get name<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->getAttribute<c- p>(</c-><c- t>'name'</c-><c- p>);</c-> <c- p>}</c->
  get type<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->localName<c- p>;</c-> <c- p>}</c->

  get checked<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->hasAttribute<c- p>(</c-><c- t>'checked'</c-><c- p>);</c-> <c- p>}</c->
  set checked<c- p>(</c->flag<c- p>)</c-> <c- p>{</c-> <c- k>this</c-><c- p>.</c->toggleAttribute<c- p>(</c-><c- t>'checked'</c-><c- p>,</c-> Boolean<c- p>(</c->flag<c- p>));</c-> <c- p>}</c->

  attributeChangedCallback<c- p>(</c->name<c- p>,</c-> oldValue<c- p>,</c-> newValue<c- p>)</c-> <c- p>{</c->
    <c- c1>// name will always be "checked" due to observedAttributes</c->
    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->setFormValue<c- p>(</c-><c- k>this</c-><c- p>.</c->checked <c- o>?</c-> <c- t>'on'</c-> <c- o>:</c-> <c- kc>null</c-><c- p>);</c->
  <c- p>}</c->

  _onClick<c- p>(</c->event<c- p>)</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->checked <c- o>=</c-> <c- o>!</c-><c- k>this</c-><c- p>.</c->checked<c- p>;</c->
  <c- p>}</c->
<c- p>}</c->
customElements<c- p>.</c->define<c- p>(</c-><c- t>'my-checkbox'</c-><c- p>,</c-> MyCheckbox<c- p>);</c-></code></pre>

  <p>カスタム要素<code>my-checkbox</code>は、組み込みのフォームに関連付けられた要素のように使うことができる。たとえば、<code id="custom-elements-face-example:the-form-element"><a href="forms.html#the-form-element">form</a></code>または<code id="custom-elements-face-example:the-label-element"><a href="forms.html#the-label-element">label</a></code> の中に置くことで<code>my-checkbox</code>要素が関連付けられ、<code id="custom-elements-face-example:the-form-element-2"><a href="forms.html#the-form-element">form</a></code>を送信することで<code>my-checkbox</code>実装で提供されるデータが送信される。</p>

  <pre><code class='html'><c- p>&lt;</c-><c- f>form</c-> <c- e>action</c-><c- o>=</c-><c- s>"..."</c-> <c- e>method</c-><c- o>=</c-><c- s>"..."</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>label</c-><c- p>>&lt;</c-><c- f>my-checkbox</c-> <c- e>name</c-><c- o>=</c-><c- s>"agreed"</c-><c- p>>&lt;/</c-><c- f>my-checkbox</c-><c- p>></c-> I read the agreement.<c- p>&lt;/</c-><c- f>label</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>input</c-> <c- e>type</c-><c- o>=</c-><c- s>"submit"</c-><c- p>></c->
<c- p>&lt;/</c-><c- f>form</c-><c- p>></c->
</code></pre>

  <h5 id="custom-elements-accessibility-example"><span class="secno">4.13.1.3</span> デフォルトでアクセシブルなロール、ステート、およびプロパティをもつカスタム要素を作成する<a href="#custom-elements-accessibility-example" class="self-link"></a></h5>

  

  <p><code>ElementInternals</code>の適切なプロパティを使用することにより、カスタム要素はデフォルトのアクセシビリティセマンティックスを持つことができる。 次のコードは、前のセクションのフォームに関連付けられたチェックボックスを拡張して、アクセシビリティ技術から見たデフォルトのロールおよびチェック状態を適切に設定する：</p>

  <pre><code class='js'><c- a>class</c-> MyCheckbox <c- k>extends</c-> HTMLElement <c- p>{</c->
  <c- k>static</c-> formAssociated <c- o>=</c-> <c- kc>true</c-><c- p>;</c->
  <c- k>static</c-> observedAttributes <c- o>=</c-> <c- p>[</c-><c- t>'checked'</c-><c- p>];</c->

  constructor<c- p>()</c-> <c- p>{</c->
    <c- k>super</c-><c- p>();</c->
    <c- k>this</c-><c- p>.</c->_internals <c- o>=</c-> <c- k>this</c-><c- p>.</c->attachInternals<c- p>();</c->
    <c- k>this</c-><c- p>.</c->addEventListener<c- p>(</c-><c- t>'click'</c-><c- p>,</c-> <c- k>this</c-><c- p>.</c->_onClick<c- p>.</c->bind<c- p>(</c-><c- k>this</c-><c- p>));</c->

<mark>    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->role <c- o>=</c-> <c- t>'checkbox'</c-><c- p>;</c->
    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->ariaChecked <c- o>=</c-> <c- kc>false</c-><c- p>;</c-></mark>
  <c- p>}</c->

  get form<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->form<c- p>;</c-> <c- p>}</c->
  get name<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->getAttribute<c- p>(</c-><c- t>'name'</c-><c- p>);</c-> <c- p>}</c->
  get type<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->localName<c- p>;</c-> <c- p>}</c->

  get checked<c- p>()</c-> <c- p>{</c-> <c- k>return</c-> <c- k>this</c-><c- p>.</c->getAttribute<c- p>(</c-><c- t>'checked'</c-><c- p>);</c-> <c- p>}</c->
  set checked<c- p>(</c->flag<c- p>)</c-> <c- p>{</c-> <c- k>this</c-><c- p>.</c->toggleAttribute<c- p>(</c-><c- t>'checked'</c-><c- p>,</c-> Boolean<c- p>(</c->flag<c- p>));</c-> <c- p>}</c->

  attributeChangedCallback<c- p>(</c->name<c- p>,</c-> oldValue<c- p>,</c-> newValue<c- p>)</c-> <c- p>{</c->
    <c- c1>// name will always be "checked" due to observedAttributes</c->
    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->setFormValue<c- p>(</c-><c- k>this</c-><c- p>.</c->checked <c- o>?</c-> <c- t>'on'</c-> <c- o>:</c-> <c- kc>null</c-><c- p>);</c->
<mark>    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->ariaChecked <c- o>=</c-> <c- k>this</c-><c- p>.</c->checked<c- p>;</c-></mark>
  <c- p>}</c->

  _onClick<c- p>(</c->event<c- p>)</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->checked <c- o>=</c-> <c- o>!</c-><c- k>this</c-><c- p>.</c->checked<c- p>;</c->
  <c- p>}</c->
<c- p>}</c->
customElements<c- p>.</c->define<c- p>(</c-><c- t>'my-checkbox'</c-><c- p>,</c-> MyCheckbox<c- p>);</c-></code></pre>

  <p>組み込み要素の場合と同様に、これらはデフォルトにすぎず、<code id="custom-elements-accessibility-example:attr-aria-role"><a href="infrastructure.html#attr-aria-role">role</a></code>および<code id="custom-elements-accessibility-example:attr-aria-*"><a href="infrastructure.html#attr-aria-*">aria-*</a></code>属性を使用するページ著者によって上書きできることに注意する：</p>

  <pre class="bad"><code class='html'><c- c>&lt;!-- This markup is non-conforming --></c->
<c- p>&lt;</c-><c- f>input</c-> <c- e>type</c-><c- o>=</c-><c- s>"checkbox"</c-> <c- e>checked</c-> <c- e>role</c-><c- o>=</c-><c- s>"button"</c-> <c- e>aria-checked</c-><c- o>=</c-><c- s>"false"</c-><c- p>></c-></code></pre>

<pre class="bad"><code class='html'><c- c>&lt;!-- This markup is probably not what the custom element author intended --></c->
<c- p>&lt;</c-><c- f>my-checkbox</c-> <c- e>role</c-><c- o>=</c-><c- s>"button"</c-> <c- e>checked</c-> <c- e>aria-checked</c-><c- o>=</c-><c- s>"false"</c-><c- p>></c-></code></pre>

  <p>カスタム要素の著者は、アクセシビリティセマンティックスのどの側面が強いネイティヴセマンティックスであるかを説明することが勧められる。つまり、カスタム要素のユーザーによって上書きされるべきではない。この例では、<code>my-checkbo</code>x要素の著者は、その<a id="custom-elements-accessibility-example:role" href="http://momdo.github.io/wai-aria-1.2/#dfn-role" data-x-internal="role">role</a>および<code id="custom-elements-accessibility-example:attr-aria-checked"><a data-x-internal="attr-aria-checked" href="http://momdo.github.io/wai-aria-1.2/#aria-checked">aria-checked</a></code>値は強いネイティヴセマンティックスであるため、上記のようなコードを勧めないと述べている。</p>

  <h5 id="custom-elements-customized-builtin-example"><span class="secno">4.13.1.4</span> カスタマイズされた組み込み要素の作成<a href="#custom-elements-customized-builtin-example" class="self-link"></a></h5>

  

  <p><a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element">カスタマイズされた組み込み要素</a>は、<a href="#autonomous-custom-element" id="custom-elements-customized-builtin-example:autonomous-custom-element">自律カスタム要素</a>とはわずかに異なる定義があり、そして大きく異なる使われ方をする、独自の種類の<a href="#custom-element" id="custom-elements-customized-builtin-example:custom-element">カスタム要素</a>である。この要素は、新しいカスタム機能でHTMLの既存要素を拡張することで、HTMLの既存要素由来の動作の再利用を可能にするために存在する。残念なことに、HTML要素の既存の動作の多くが<a href="#autonomous-custom-element" id="custom-elements-customized-builtin-example:autonomous-custom-element-2">自律カスタム要素</a>を純粋に使用して複製できないため、これは重要である。代わりに、<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-2">カスタマイズされた組み込み要素</a>は、既存の要素にカスタム構築動作、ライフサイクルフック、およびプロトタイプチェーンのインストールを可能にし、既存の要素の上にこれらの機能を本質的に"混在"させる。</p>

  <p><a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-3">カスタマイズされた組み込み要素</a>は、ユーザーエージェントや他のソフトウェアが要素のセマンティックスおよび動作を識別するために要素のローカル名として扱うので、<a href="#autonomous-custom-element" id="custom-elements-customized-builtin-example:autonomous-custom-element-3">自律カスタム要素</a>とは異なる構文を必要とする。つまり、既存の動作の上に構築する<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-4">カスタマイズされた組み込み要素</a>の概念は、元のローカル名を保持する拡張要素に決定的に依存する。</p>

  <p>この例において、<code>plastic-button</code>という<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-5">カスタマイズされた組み込み要素</a>を作成する。これは通常のボタンのように動作するが、クリックするたびにファンシーなアニメーション効果が追加される。今回は<code>HTMLElement</code>の代わりに<code>HTMLButtonElement</code>を拡張するが、前と同じようにクラスを定義することから始める：</p>

  <pre><code class='js'><c- a>class</c-> PlasticButton <c- k>extends</c-> HTMLButtonElement <c- p>{</c->
  constructor<c- p>()</c-> <c- p>{</c->
    <c- k>super</c-><c- p>();</c->

    <c- k>this</c-><c- p>.</c->addEventListener<c- p>(</c-><c- u>"click"</c-><c- p>,</c-> <c- p>()</c-> <c- p>=></c-> <c- p>{</c->
      <c- c1>// Draw some fancy animation effects!</c->
    <c- p>});</c->
  <c- p>}</c->
<c- p>}</c-></code></pre>

  <p>カスタム要素を定義する場合、<code>extends</code>オプションも指定する必要がある：</p>

  <pre><code class='js'>customElements<c- p>.</c->define<c- p>(</c-><c- u>"plastic-button"</c-><c- p>,</c-> PlasticButton<c- p>,</c-> <c- p>{</c-> <c- k>extends</c-><c- o>:</c-> <c- u>"button"</c-> <c- p>});</c-></code></pre>

  <p>一般に、拡張されている要素の名前は、同じインターフェイスを共有する要素（<code>HTMLQuoteElement</code>を共有する<code id="custom-elements-customized-builtin-example:the-q-element"><a href="text-level-semantics.html#the-q-element">q</a></code>と<code id="custom-elements-customized-builtin-example:the-blockquote-element"><a href="grouping-content.html#the-blockquote-element">blockquote</a></code>の両者など）を共有するため、拡張する要素インターフェイスを単に調べるだけでは判断することができない。</p>

  <p>解析されたHTMLソーステキストから<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-6">カスタマイズされた組み込み要素</a>を構築するには、<code id="custom-elements-customized-builtin-example:the-button-element"><a href="form-elements.html#the-button-element">button</a></code>要素の<code id="custom-elements-customized-builtin-example:attr-is"><a href="#attr-is">is</a></code>属性を使用する。</p>

  <pre><code class='html'><c- p>&lt;</c-><c- f>button</c-> <c- e>is</c-><c- o>=</c-><c- s>"plastic-button"</c-><c- p>></c->Click Me!<c- p>&lt;/</c-><c- f>button</c-><c- p>></c-></code></pre>

  <p><a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-7">カスタマイズされた組み込み要素</a>を<a href="#autonomous-custom-element" id="custom-elements-customized-builtin-example:autonomous-custom-element-4">自律カスタム要素</a>として使用しようとするとうまく<em>いかない</em>。つまり、<code>&lt;plastic-button>Click me?&lt;/plastic-button></code>は特別な動作をしない<code>HTMLElement</code>を作成するだけである。</p>

  <p>プログラムでカスタマイズしたビルトイン要素を作成する必要がある場合、次の<code id="custom-elements-customized-builtin-example:dom-document-createelement"><a data-x-internal="dom-document-createelement" href="https://triple-underscore.github.io/DOM4-ja.html#dom-document-createelement">createElement()</a></code>の形式を使用することができる：</p>

  <pre><code class='js'><c- a>const</c-> plasticButton <c- o>=</c-> document<c- p>.</c->createElement<c- p>(</c-><c- u>"button"</c-><c- p>,</c-> <c- p>{</c-> is<c- o>:</c-> <c- u>"plastic-button"</c-> <c- p>});</c->
plasticButton<c- p>.</c->textContent <c- o>=</c-> <c- u>"Click me!"</c-><c- p>;</c-></code></pre>

  <p>前と同じように、コンストラクターも動作する：</p>

  <pre><code class='js'><c- a>const</c-> plasticButton2 <c- o>=</c-> <c- k>new</c-> PlasticButton<c- p>();</c->
console<c- p>.</c->log<c- p>(</c->plasticButton2<c- p>.</c->localName<c- p>);</c->  <c- c1>// will output "button"</c->
console<c- p>.</c->assert<c- p>(</c->plasticButton2 <c- k>instanceof</c-> PlasticButton<c- p>);</c->
console<c- p>.</c->assert<c- p>(</c->plasticButton2 <c- k>instanceof</c-> HTMLButtonElement<c- p>);</c-></code></pre>

  <p>プログラムでカスタマイズした組み込み要素を作成する場合、明示的に設定されていないので<code id="custom-elements-customized-builtin-example:attr-is-2"><a href="#attr-is">is</a></code>属性はDOMに存在しない。ただし、<a href="#attr-is-during-serialization">シリアライズ時に出力に追加される</a>。</p>

  <pre><code class='js'>console<c- p>.</c->assert<c- p>(</c-><c- o>!</c->plasticButton<c- p>.</c->hasAttribute<c- p>(</c-><c- u>"is"</c-><c- p>));</c->
console<c- p>.</c->log<c- p>(</c->plasticButton<c- p>.</c->outerHTML<c- p>);</c-> <c- c1>// will output '&lt;button is="plastic-button">&lt;/button>'</c-></code></pre>

  <p>作成方法に関係なく、<code id="custom-elements-customized-builtin-example:the-button-element-2"><a href="form-elements.html#the-button-element">button</a></code>が特別であるすべての方法は、そのような"プラスチックボタン"にも適用される：フォーカス動作、<span>フォーム送信</span>に関与する能力、<code id="custom-elements-customized-builtin-example:attr-fe-disabled"><a href="form-control-infrastructure.html#attr-fe-disabled">disabled</a></code>属性など。</p>

  <p id="customized-built-in-element-restrictions"><a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-8">カスタマイズされた組み込み要素</a>は、有用なユーザーエージェントが提供する動作またはAPIを持つ既存のHTML要素の拡張を可能にするように設計されている。そのため、この仕様で定義される既存のHTML要素のみを拡張することができ、<a id="custom-elements-customized-builtin-example:element-interface" href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-interface" data-x-internal="element-interface">要素インターフェイス</a>として<code>HTMLUnknownElement</code>を使用するように定義された<code id="custom-elements-customized-builtin-example:bgsound"><a href="obsolete.html#bgsound">bgsound</a></code>、<code id="custom-elements-customized-builtin-example:blink"><a href="obsolete.html#blink">blink</a></code>、<code id="custom-elements-customized-builtin-example:isindex"><a href="obsolete.html#isindex">isindex</a></code>、<code id="custom-elements-customized-builtin-example:keygen"><a href="obsolete.html#keygen">keygen</a></code>、<code id="custom-elements-customized-builtin-example:multicol"><a href="obsolete.html#multicol">multicol</a></code>、<code id="custom-elements-customized-builtin-example:nextid"><a href="obsolete.html#nextid">nextid</a></code>、または<code id="custom-elements-customized-builtin-example:spacer"><a href="obsolete.html#spacer">spacer</a></code>などのレガシー要素は拡張できない。</p>

  <p>この要件の1つの理由は将来の互換性である。もし<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-9">カスタマイズされた組み込み要素</a>が、たとえば<code>combobox</code>のような、現在不明の要素を拡張したものが定義されたなら、派生した<a href="#customized-built-in-element" id="custom-elements-customized-builtin-example:customized-built-in-element-10">カスタマイズされた組み込み要素</a>のコンシューマーが、ユーザーエージェント提供の動作に興味を持たない基本要素に依存するようになるため、これはこの仕様が将来<code>combobox</code>要素を定義することを妨げるかもしれない。</p>

  <h5 id="custom-elements-autonomous-drawbacks"><span class="secno">4.13.1.5</span> 自律カスタム要素の欠点<a href="#custom-elements-autonomous-drawbacks" class="self-link"></a></h5>

  

  <p>以下で規定されているように、そして上記で触れたように、単に<code>taco-button</code>という要素を定義して使用しても、そのような要素がボタンを<a href="dom.html#represents" id="custom-elements-autonomous-drawbacks:represents">表す</a>ことを意味しない。つまり、ウェブブラウザー、検索エンジン、アクセシビリティ技術などのツールは、定義された名前だけに基づいて、結果の要素をボタンとして自動的に処理しない。</p>

  <p><a href="#autonomous-custom-element" id="custom-elements-autonomous-drawbacks:autonomous-custom-element">自律カスタム要素</a>を依然として使用する一方で、様々なユーザーに所望のボタンセマンティックスを伝えるためためには、複数の技術を用いる必要がある：</p>

  <ul><li><p><code id="custom-elements-autonomous-drawbacks:attr-tabindex"><a href="interaction.html#attr-tabindex">tabindex</a></code>属性の追加は、<code>taco-button</code>を<span>フォーカス可能</span>にする。もし<code>taco-button</code>を論理的に無効にするならば、<code id="custom-elements-autonomous-drawbacks:attr-tabindex-2"><a href="interaction.html#attr-tabindex">tabindex</a></code>属性を削除する必要があるだろうことに注意すること。<li><p>ARIAロールならびにさまざまなARIAステートおよびプロパティの追加は、セマンティックスをアクセシビリティ技術に伝えるのに役立つ。 たとえば、<a id="custom-elements-autonomous-drawbacks:role" href="http://momdo.github.io/wai-aria-1.2/#dfn-role" data-x-internal="role">role</a>を"<code id="custom-elements-autonomous-drawbacks:attr-aria-role-button"><a data-x-internal="attr-aria-role-button" href="https://momdo.github.io/wai-aria-1.2/#button">button</a></code>"に設定すると、これがボタンであるというセマンティックスを伝え、支援技術で通常のボタンのような操作を使用してコントロールをユーザーが正常に操作できる。ボタンに<a href="http://momdo.github.io/wai-aria-1.2/#dfn-accessible-name" id="custom-elements-autonomous-drawbacks:concept-accessible-name" data-x-internal="concept-accessible-name">アクセシブルな名前</a>を付けるには、<code id="custom-elements-autonomous-drawbacks:attr-aria-label"><a data-x-internal="attr-aria-label" href="http://momdo.github.io/wai-aria-1.2/#aria-label">aria-label</a></code>プロパティを設定する必要がある。代わりに、アクセシビリティ技術でその子のテキストノードを縦走して通知する必要はない。そして、ボタンが論理的に無効になっているときに<code id="custom-elements-autonomous-drawbacks:attr-aria-disabled"><a data-x-internal="attr-aria-disabled" href="http://momdo.github.io/wai-aria-1.2/#aria-disabled">aria-disabled</a></code>ステートを"<code>true</code>"に設定すると、アクセシビリティ技術にボタンの無効状態を伝える。<li><p>通常予想されるボタンの動作を処理するイベントハンドラーを追加することにより、ボタンのセマンティックスをウェブブラウザーのユーザーに伝えることを手伝う。この場合、最も関連性の高いイベントハンドラーは、適切な<code id="custom-elements-autonomous-drawbacks:event-keydown"><a data-x-internal="event-keydown" href="https://triple-underscore.github.io/uievents-ja.htmluievents-ja.html#event-type-keydown">keydown</a></code>イベントを<code id="custom-elements-autonomous-drawbacks:event-click"><a data-x-internal="event-click" href="https://triple-underscore.github.io/uievents-ja.htmluievents-ja.html#event-type-click">click</a></code>イベントとしてプロキシーするものであるので、キーボードとクリックの両方でボタンをアクティブにすることができる。<li><p><code>taco-button</code>要素に提供される任意のデフォルトの視覚スタイリングに加えて、視覚スタイリングはまた、例えば無効になるなど、論理状態の変化を反映するように更新される必要がある。つまり、<code>taco-button</code>の規則を持つスタイルシートはすべて、<code>taco-button[disabled]</code>の規則も必要となる。</ul>

  <p>これらの点を念頭に置いて、（無効にする機能を含む）ボタンのセマンティックスを伝える責任を負ったフル機能の<code>taco-button</code>は、次のようになる：</p>

  <pre><code class='js'><c- a>class</c-> TacoButton <c- k>extends</c-> HTMLElement <c- p>{</c->
  <c- k>static</c-> observedAttributes <c- o>=</c-> <c- p>[</c-><c- u>"disabled"</c-><c- p>];</c->

  constructor<c- p>()</c-> <c- p>{</c->
    <c- k>super</c-><c- p>();</c->
    <c- k>this</c-><c- p>.</c->_internals <c- o>=</c-> <c- k>this</c-><c- p>.</c->attachInternals<c- p>();</c->
    <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->role <c- o>=</c-> <c- u>"button"</c-><c- p>;</c->

    <c- k>this</c-><c- p>.</c->addEventListener<c- p>(</c-><c- u>"keydown"</c-><c- p>,</c-> e <c- p>=></c-> <c- p>{</c->
      <c- k>if</c-> <c- p>(</c->e<c- p>.</c->code <c- o>===</c-> <c- u>"Enter"</c-> <c- o>||</c-> e<c- p>.</c->code <c- o>===</c-> <c- u>"Space"</c-><c- p>)</c-> <c- p>{</c->
        <c- k>this</c-><c- p>.</c->dispatchEvent<c- p>(</c-><c- k>new</c-> PointerEvent<c- p>(</c-><c- u>"click"</c-><c- p>,</c-> <c- p>{</c->
          bubbles<c- o>:</c-> <c- kc>true</c-><c- p>,</c->
          cancelable<c- o>:</c-> <c- kc>true</c->
        <c- p>}));</c->
      <c- p>}</c->
    <c- p>});</c->

    <c- k>this</c-><c- p>.</c->addEventListener<c- p>(</c-><c- u>"click"</c-><c- p>,</c-> e <c- p>=></c-> <c- p>{</c->
      <c- k>if</c-> <c- p>(</c-><c- k>this</c-><c- p>.</c->disabled<c- p>)</c-> <c- p>{</c->
        e<c- p>.</c->preventDefault<c- p>();</c->
        e<c- p>.</c->stopImmediatePropagation<c- p>();</c->
      <c- p>}</c->
    <c- p>});</c->

    <c- k>this</c-><c- p>.</c->_observer <c- o>=</c-> <c- k>new</c-> MutationObserver<c- p>(()</c-> <c- p>=></c-> <c- p>{</c->
      <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->ariaLabel <c- o>=</c-> <c- k>this</c-><c- p>.</c->textContent<c- p>;</c->
    <c- p>});</c->
  <c- p>}</c->

  connectedCallback<c- p>()</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->setAttribute<c- p>(</c-><c- u>"tabindex"</c-><c- p>,</c-> <c- u>"0"</c-><c- p>);</c->

    <c- k>this</c-><c- p>.</c->_observer<c- p>.</c->observe<c- p>(</c-><c- k>this</c-><c- p>,</c-> <c- p>{</c->
      childList<c- o>:</c-> <c- kc>true</c-><c- p>,</c->
      characterData<c- o>:</c-> <c- kc>true</c-><c- p>,</c->
      subtree<c- o>:</c-> <c- kc>true</c->
    <c- p>});</c->
  <c- p>}</c->

  disconnectedCallback<c- p>()</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->_observer<c- p>.</c->disconnect<c- p>();</c->
  <c- p>}</c->

  get disabled<c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- k>this</c-><c- p>.</c->hasAttribute<c- p>(</c-><c- u>"disabled"</c-><c- p>);</c->
  <c- p>}</c->
  set disabled<c- p>(</c->flag<c- p>)</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->toggleAttribute<c- p>(</c-><c- u>"disabled"</c-><c- p>,</c-> Boolean<c- p>(</c->flag<c- p>));</c->
  <c- p>}</c->

  attributeChangedCallback<c- p>(</c->name<c- p>,</c-> oldValue<c- p>,</c-> newValue<c- p>)</c-> <c- p>{</c->
    <c- c1>// name will always be "disabled" due to observedAttributes</c->
    <c- k>if</c-> <c- p>(</c-><c- k>this</c-><c- p>.</c->disabled<c- p>)</c-> <c- p>{</c->
      <c- k>this</c-><c- p>.</c->removeAttribute<c- p>(</c-><c- u>"tabindex"</c-><c- p>);</c->
      <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->ariaDisabled <c- o>=</c-> <c- u>"true"</c-><c- p>;</c->
    <c- p>}</c-> <c- k>else</c-> <c- p>{</c->
      <c- k>this</c-><c- p>.</c->setAttribute<c- p>(</c-><c- u>"tabindex"</c-><c- p>,</c-> <c- u>"0"</c-><c- p>);</c->
      <c- k>this</c-><c- p>.</c->_internals<c- p>.</c->ariaDisabled <c- o>=</c-> <c- u>"false"</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}</c->
<c- p>}</c-></code></pre>

  <p>このかなり複雑な要素定義であっても、要素はカスタマーに使用する喜びとはならない。その要素は、自身の意志の<code id="custom-elements-autonomous-drawbacks:attr-tabindex-3"><a href="interaction.html#attr-tabindex">tabindex</a></code>属性を継続的に"発芽"し、<code>tabindex="0"</code>フォーカス機能の動作の選択は、現在のプラットフォームの<code id="custom-elements-autonomous-drawbacks:the-button-element"><a href="form-elements.html#the-button-element">button</a></code>動作と一致しなくてもよい 。これは、（通常、コンシューマーがデフォルトの動作を上書きできるように予約されているにもかかわらず）そのために<code id="custom-elements-autonomous-drawbacks:attr-tabindex-4"><a href="interaction.html#attr-tabindex">tabindex</a></code>属性の使用を強制する、現時点では、カスタム要素のデフォルトのフォーカス動作を指定する方法がないためである。</p>

  <p>対照的に、前節で示したように、単一の<a href="#customized-built-in-element" id="custom-elements-autonomous-drawbacks:customized-built-in-element">カスタマイズされた組み込み要素</a>は、<code id="custom-elements-autonomous-drawbacks:the-button-element-2"><a href="form-elements.html#the-button-element">button</a></code>要素のセマンティックスと動作を自動的に継承する。これらの動作を手動で実装する必要はない。一般に、HTMLの既存要素の上に構築される重要な動作やセマンティックスを持つ要素については、<a href="#customized-built-in-element" id="custom-elements-autonomous-drawbacks:customized-built-in-element-2">カスタマイズされた組み込み要素</a>の開発、保守、および消費が容易になる。</p>

  <h5 id="custom-elements-upgrades-examples"><span class="secno">4.13.1.6</span> 作成後の要素のアップグレード<a href="#custom-elements-upgrades-examples" class="self-link"></a></h5>

  

  <p><a href="#element-definition" id="custom-elements-upgrades-examples:element-definition">要素定義</a>はいつでも発生する可能性があるため、非カスタム要素が<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-create-element" id="custom-elements-upgrades-examples:create-an-element" data-x-internal="create-an-element">作成され</a>、適切な<span>定義</span>を登録した後で<a href="#custom-element" id="custom-elements-upgrades-examples:custom-element">カスタム要素</a>にすることができる。 このプロセスを、通常の要素からカスタム要素に要素を"アップグレードする"と呼ぶ。</p>

  <p><span>アップグレード</span>は、パーサーなどで関連する要素が最初に作成された後に、<span>カスタム要素定義</span>を登録することが望ましい場合のシナリオを可能にする。これにより、カスタム要素内のコンテンツを段階的に強化することができる。例えば、以下の HTML文書において、<code>img-viewer</code>の要素定義は非同期的にロードされる：</p>

  <pre><code class='html'><c- cp>&lt;!DOCTYPE html></c->
<c- p>&lt;</c-><c- f>html</c-> <c- e>lang</c-><c- o>=</c-><c- s>"en"</c-><c- p>></c->
<c- p>&lt;</c-><c- f>title</c-><c- p>></c->Image viewer example<c- p>&lt;/</c-><c- f>title</c-><c- p>></c->

<c- p>&lt;</c-><c- f>img-viewer</c-> <c- e>filter</c-><c- o>=</c-><c- s>"Kelvin"</c-><c- p>></c->
  <c- p>&lt;</c-><c- f>img</c-> <c- e>src</c-><c- o>=</c-><c- s>"images/tree.jpg"</c-> <c- e>alt</c-><c- o>=</c-><c- s>"A beautiful tree towering over an empty savannah"</c-><c- p>></c->
<c- p>&lt;/</c-><c- f>img-viewer</c-><c- p>></c->

<c- p>&lt;</c-><c- f>script</c-> <c- e>src</c-><c- o>=</c-><c- s>"js/elements/img-viewer.js"</c-> <c- e>async</c-><c- p>>&lt;/</c-><c- f>script</c-><c- p>></c-></code></pre>

  <p>ここでの<code>img-viewer</code>要素の定義は、マークアップで<code>&lt;img-viewer></code>タグの後に配置された、<code id="custom-elements-upgrades-examples:attr-script-async"><a href="scripting.html#attr-script-async">async</a></code>属性でマークされた<code id="custom-elements-upgrades-examples:the-script-element"><a href="scripting.html#the-script-element">script</a></code>要素を用いて読み込まれる。 スクリプトの読み込み中、<code>img-viewer</code>要素は、<code id="custom-elements-upgrades-examples:the-span-element"><a href="text-level-semantics.html#the-span-element">span</a></code>と同様に未定義の要素として扱われる。 スクリプトが読み込まれると、<code>img-viewer</code>要素が定義され、ページ上の既存の<code>img-viewer</code>要素は、カスタム要素の定義が適用してアップグレードされる（これはおそらく、文字列"Kelvin"によって識別される画像フィルターの適用し、画像の視覚的外観を向上させることが含まれる ）。</p>

  <hr>

  <p><span>アップグレード</span>は文書ツリー内の要素にのみ適用されることに注意する。（正式には、<a id="custom-elements-upgrades-examples:connected" href="https://triple-underscore.github.io/DOM4-ja.html#connected" data-x-internal="connected">接続される</a>要素。）文書に挿入されない要素は、アップグレードされないままである。例はこの点を説明する：</p>

  <pre><code class='html'><c- cp>&lt;!DOCTYPE html></c->
<c- p>&lt;</c-><c- f>html</c-> <c- e>lang</c-><c- o>=</c-><c- s>"en"</c-><c- p>></c->
<c- p>&lt;</c-><c- f>title</c-><c- p>></c->Upgrade edge-cases example<c- p>&lt;/</c-><c- f>title</c-><c- p>></c->

<c- p>&lt;</c-><c- f>example-element</c-><c- p>>&lt;/</c-><c- f>example-element</c-><c- p>></c->

<c- p>&lt;</c-><c- f>script</c-><c- p>></c->
  <c- u>"use strict"</c-><c- p>;</c->

  <c- a>const</c-> inDocument <c- o>=</c-> document<c- p>.</c->querySelector<c- p>(</c-><c- u>"example-element"</c-><c- p>);</c->
  <c- a>const</c-> outOfDocument <c- o>=</c-> document<c- p>.</c->createElement<c- p>(</c-><c- u>"example-element"</c-><c- p>);</c->

  <c- c1>// Before the element definition, both are HTMLElement:</c->
  console<c- p>.</c->assert<c- p>(</c->inDocument <c- k>instanceof</c-> HTMLElement<c- p>);</c->
  console<c- p>.</c->assert<c- p>(</c->outOfDocument <c- k>instanceof</c-> HTMLElement<c- p>);</c->

  <c- a>class</c-> ExampleElement <c- k>extends</c-> HTMLElement <c- p>{}</c->
  customElements<c- p>.</c->define<c- p>(</c-><c- u>"example-element"</c-><c- p>,</c-> ExampleElement<c- p>);</c->

  <c- c1>// After element definition, the in-document element was upgraded:</c->
  console<c- p>.</c->assert<c- p>(</c->inDocument <c- k>instanceof</c-> ExampleElement<c- p>);</c->
  console<c- p>.</c->assert<c- p>(</c-><c- o>!</c-><c- p>(</c->outOfDocument <c- k>instanceof</c-> ExampleElement<c- p>));</c->

  document<c- p>.</c->body<c- p>.</c->appendChild<c- p>(</c->outOfDocument<c- p>);</c->

  <c- c1>// Now that we've moved the element into the document, it too was upgraded:</c->
  console<c- p>.</c->assert<c- p>(</c->outOfDocument <c- k>instanceof</c-> ExampleElement<c- p>);</c->
<c- p>&lt;/</c-><c- f>script</c-><c- p>></c-></code></pre>

  <h4 id="custom-element-conformance"><span class="secno">4.13.2</span> カスタム要素のコンストラクターと反応の要件<a href="#custom-element-conformance" class="self-link"></a></h4>

  <p><a href="#custom-element-constructor" id="custom-element-conformance:custom-element-constructor">カスタム要素コンストラクター</a>をオーサリングするとき、著者は以下の適合性要件に拘束される：</p>

  <ul><li><p>それ以上のコードを実行する前に正しいプロトタイプチェーンおよび<b>this</b>値を確立するために、パラメーターレスの<code>super()</code>の呼び出しは、コンストラクター本体の最初のステートメントでなければならない。<li><p><code>return</code>ステートメントは、単純な早期復帰（<code>return</code> または<code>return this</code>）でない限り、コンストラクター本体のどこにも現れてはならない。<li><p>コンストラクターは<code id="custom-element-conformance:dom-document-write"><a href="dynamic-markup-insertion.html#dom-document-write">document.write()</a></code> または<code id="custom-element-conformance:dom-document-open"><a href="dynamic-markup-insertion.html#dom-document-open">document.open()</a></code>メソッドを使用してはならない。<li><p>非<span>アップグレード</span>の場合は存在しないため、要素の属性および子は検査してはならず、アップグレードに依存すると、要素の使用が困難になる。<li><p>これは、<code id="custom-element-conformance:dom-document-createelement"><a data-x-internal="dom-document-createelement" href="https://triple-underscore.github.io/DOM4-ja.html#dom-document-createelement">createElement</a></code>または<code id="custom-element-conformance:dom-document-createelementns"><a data-x-internal="dom-document-createelementns" href="https://triple-underscore.github.io/DOM4-ja.html#dom-document-createelementns">createElementNS</a></code>メソッドを使用するコンシューマーの期待に違反するため、要素は属性または子を取得してはならない。<li><p>一般に、作業は可能な限り<code>connectedCallback</code>に延期されるべきであり、特にリソースのフェッチまたはレンダリングに関連する作業はそうである。しかし、<code>connectedCallback</code>は複数回呼び出すことができるため、本当に1回のみの初期化作業では、2回実行されないようにガードが必要になることに注意する。<li><p>一般に、コンストラクターは、初期状態およびデフォルト値を設定し、イベントリスナーおよび場合によっては<a id="custom-element-conformance:shadow-root" href="https://triple-underscore.github.io/DOM4-ja.html#concept-shadow-root" data-x-internal="shadow-root">シャドウルート</a>を設定するために使用されるべきである。</ul>

  <p>これらの要件のいくつかは、<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-create-element" id="custom-element-conformance:create-an-element" data-x-internal="create-an-element">要素の作成中</a>に直接的または間接的のいずれかでチェックされ、それらに従わないと、パーサーまたはDOM APIによってインスタンス化できないカスタム要素をもたらす。これは、たとえコンストラクターによって開始された<span>マイクロタスク</span>内で作業が行われるとしても当てはまる。<span>マイクロタスクのチェックポイント</span>は、作成直後に発生する可能性があるためである。</p>

  <p><a href="#concept-custom-element-reaction" id="custom-element-conformance:concept-custom-element-reaction">カスタム要素反応</a>を作成する場合、予期しない結果が生じる可能性があるため、ノードツリーの操作を避けるべきである。</p>

  <div class="example"><p>要素の<code>connectedCallback</code>は、要素が切断される前にキューに入れることができるが、コールバックキューはまだ処理されているため、接続されなくなった要素の<code>connectedCallback</code>をもたらす：</p>

   <pre><code class='js'><c- a>class</c-> CParent <c- k>extends</c-> HTMLElement <c- p>{</c->
  connectedCallback<c- p>()</c-> <c- p>{</c->
    <c- k>this</c-><c- p>.</c->firstChild<c- p>.</c->remove<c- p>();</c->
  <c- p>}</c->
<c- p>}</c->
customElements<c- p>.</c->define<c- p>(</c-><c- u>"c-parent"</c-><c- p>,</c-> CParent<c- p>);</c->

<c- a>class</c-> CChild <c- k>extends</c-> HTMLElement <c- p>{</c->
  connectedCallback<c- p>()</c-> <c- p>{</c->
    console<c- p>.</c->log<c- p>(</c-><c- u>"CChild connectedCallback: isConnected ="</c-><c- p>,</c-> <c- k>this</c-><c- p>.</c->isConnected<c- p>);</c->
  <c- p>}</c->
<c- p>}</c->
customElements<c- p>.</c->define<c- p>(</c-><c- u>"c-child"</c-><c- p>,</c-> CChild<c- p>);</c->

<c- a>const</c-> parent <c- o>=</c-> <c- k>new</c-> CParent<c- p>(),</c->
      child <c- o>=</c-> <c- k>new</c-> CChild<c- p>();</c->
parent<c- p>.</c->append<c- p>(</c->child<c- p>);</c->
document<c- p>.</c->body<c- p>.</c->append<c- p>(</c->parent<c- p>);</c->

<c- c1>// Logs:</c->
<c- c1>// CChild connectedCallback: isConnected = false</c-></code></pre>
  </div>

  <h4 id="custom-elements-core-concepts"><span class="secno">4.13.3</span> コアコンセプト<a href="#custom-elements-core-concepts" class="self-link"></a></h4>

  <p><dfn id="custom-element" data-export="">カスタム要素</dfn>は、<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-custom" id="custom-elements-core-concepts:concept-element-custom" data-x-internal="concept-element-custom">カスタム</a>である要素となる。非公式には、そのコンストラクターおよびプロトタイプが、ユーザーエージェントによってではなく、著者によって定義されていることを意味する。この著者が提供するコンストラクター関数を<dfn id="custom-element-constructor" data-export="">カスタム要素コンストラクター</dfn>と呼ぶ。</p>

  <p>2つの異なるタイプの<a href="#custom-element" id="custom-elements-core-concepts:custom-element">カスタム要素</a>を定義できる：</p>

  <div class="mdn-anno wrapped before"><button onclick="toggleStatus(this)" class="mdn-anno-btn"><span>MDN</span></button><div class="feature"><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is" title="The is global attribute allows you to specify that a standard HTML element should behave like a defined custom built-in element (see Using custom elements for more details).">Global_attributes/is</a><div class="support"><span class="firefox yes"><span>Firefox</span><span>63+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>67+</span></span><hr><span class="opera unknown"><span>Opera</span><span>?</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge unknown"><span>Edge (Legacy)</span><span>?</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android unknown"><span>Firefox Android</span><span>?</span></span><span class="safari_ios unknown"><span>Safari iOS</span><span>?</span></span><span class="chrome_android unknown"><span>Chrome Android</span><span>?</span></span><span class="webview_android unknown"><span>WebView Android</span><span>?</span></span><span class="samsunginternet_android unknown"><span>Samsung Internet</span><span>?</span></span><span class="opera_android unknown"><span>Opera Android</span><span>?</span></span></div></div></div><ol><li><p><dfn id="autonomous-custom-element" data-export="">自律カスタム要素</dfn>。これは、<code>extends</code>オプションなしで定義されている。 これらのタイプのカスタム要素は、<span>定義された名前</span>と同じローカル名を持つ。<li><p><dfn id="customized-built-in-element" data-export="">カスタマイズされた組み込み要素</dfn>。これは、<code>extends</code>オプションで定義されている。これらのタイプのカスタム要素は、<code>extends</code>オプションで渡される値と同じローカル名を持ち、<span>定義された名前</span>は<dfn data-dfn-for="html-global" id="attr-is" data-dfn-type="element-attr"><code>is</code></dfn>属性の値として使用され、したがってこれは<a href="#valid-custom-element-name" id="custom-elements-core-concepts:valid-custom-element-name">妥当なカスタム要素名</a>でなければならない。</ol>

  <p><a href="#custom-element" id="custom-elements-core-concepts:custom-element-2">カスタム要素</a>が<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-create-element" id="custom-elements-core-concepts:create-an-element" data-x-internal="create-an-element">作成された</a>後、<code id="custom-elements-core-concepts:attr-is"><a href="#attr-is">is</a></code>属性の値を変更しても要素の動作は変更されない。</p>

  <p><a href="#autonomous-custom-element" id="custom-elements-core-concepts:autonomous-custom-element">自律カスタム要素</a>は、以下の要素定義を持つ：</p>

  <dl class="element"><dt><a href="dom.html#concept-element-categories" id="custom-elements-core-concepts:concept-element-categories">カテゴリー</a>：<dd><a id="custom-elements-core-concepts:flow-content-2" href="dom.html#flow-content-2">フローコンテンツ</a>。<dd><a id="custom-elements-core-concepts:phrasing-content-2" href="dom.html#phrasing-content-2">フレージングコンテンツ</a>。<dd><a id="custom-elements-core-concepts:palpable-content-2" href="dom.html#palpable-content-2">パルパブルコンテンツ</a>。<dd><a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element">フォームに関連付けられたカスタム要素</a>の場合：<a href="forms.html#category-listed" id="custom-elements-core-concepts:category-listed">記載</a>、<a href="forms.html#category-label" id="custom-elements-core-concepts:category-label">ラベル付け可能</a>、<a href="forms.html#category-submit" id="custom-elements-core-concepts:category-submit">送信可能</a>、<a href="forms.html#category-reset" id="custom-elements-core-concepts:category-reset">リセット可能</a><a id="custom-elements-core-concepts:form-associated-element" href="forms.html#form-associated-element">フォームに関連付けられた要素</a>。<dt><a href="dom.html#concept-element-contexts" id="custom-elements-core-concepts:concept-element-contexts">この要素を使用できるコンテキスト</a>：<dd><a id="custom-elements-core-concepts:phrasing-content-2-2" href="dom.html#phrasing-content-2">フレージングコンテンツ</a>が期待される場所。<dt><a href="dom.html#concept-element-content-model" id="custom-elements-core-concepts:concept-element-content-model">コンテンツモデル</a>：<dd><a id="custom-elements-core-concepts:transparent" href="dom.html#transparent">透過的</a>。<dt><a href="dom.html#concept-element-attributes" id="custom-elements-core-concepts:concept-element-attributes">コンテンツ属性</a>：<dd><a id="custom-elements-core-concepts:global-attributes" href="dom.html#global-attributes">グローバル属性</a>、<code id="custom-elements-core-concepts:attr-is-2"><a href="#attr-is">is</a></code>属性を除く<dd><code id="custom-elements-core-concepts:attr-fae-form"><a href="form-control-infrastructure.html#attr-fae-form">form</a></code>、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-2">フォームに関連付けられたカスタム要素</a>の場合 — 要素を<code id="custom-elements-core-concepts:the-form-element"><a href="forms.html#the-form-element">form</a></code>要素に関連付ける<dd><code id="custom-elements-core-concepts:attr-fe-disabled"><a href="form-control-infrastructure.html#attr-fe-disabled">disabled</a></code>、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-3">フォームに関連付けられたカスタム要素</a>の場合 — フォームコントロールが無効かどうか<dd><code id="custom-elements-core-concepts:attr-face-readonly"><a href="#attr-face-readonly">readonly</a></code>、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-4">フォームに関連付けられたカスタム要素</a>の場合 — <code>willValidate</code>に影響し、カスタム要素の著者によって追加されたすべての動作<dd><code id="custom-elements-core-concepts:attr-fe-name"><a href="form-control-infrastructure.html#attr-fe-name">name</a></code>、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-5">フォームに関連付けられたカスタム要素</a>の場合 — <a id="custom-elements-core-concepts:form-submission-2" href="form-control-infrastructure.html#form-submission-2">フォームの送信</a>および<code id="custom-elements-core-concepts:dom-form-elements"><a href="forms.html#dom-form-elements">form.elements</a></code>に使用する要素の名前<dd>名前空間を持たないその他の属性（文参照）。<dt><a href="dom.html#concept-element-accessibility-considerations" id="custom-elements-core-concepts:concept-element-accessibility-considerations">アクセシビリティの考慮</a>：<dd><a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-6">フォームに関連付けられたカスタム要素</a>の場合：<a href="https://momdo.github.io/html-aria/#el-form-associated-custom-element">著者向け</a>、<a href="https://w3c.github.io/html-aam/#el-form-associated-custom-element"> 実装者向け</a>。<dd>そうでなければ：<a href="https://momdo.github.io/html-aria/#el-autonomous-custom-element">著者向け</a>、<a href="https://w3c.github.io/html-aam/#el-autonomous-custom-element">実装者向け</a>。<dt><a href="dom.html#concept-element-dom" id="custom-elements-core-concepts:concept-element-dom">DOMインターフェイス</a>：<dd>要素の著者によって提供される（<code>HTMLElement</code>から継承）</dl>


  <p><a href="#autonomous-custom-element" id="custom-elements-core-concepts:autonomous-custom-element-2">自律カスタム要素</a>は特別な意味を持たない：その要素の子を<a id="custom-elements-core-concepts:represents" href="dom.html#represents">表す</a>。<a href="#customized-built-in-element" id="custom-elements-core-concepts:customized-built-in-element">カスタマイズされた組み込み要素</a>は、それが拡張した要素のセマンティックスを継承する。</p>

  <p>要素の著者によって決定された、要素の機能に関連する名前空間なしの属性は、属性名が<a id="custom-elements-core-concepts:xml-compatible" href="infrastructure.html#xml-compatible">XML互換</a>、かつ<a href="https://triple-underscore.github.io/infra-ja.html#ascii-upper-alpha" id="custom-elements-core-concepts:uppercase-ascii-letters" data-x-internal="uppercase-ascii-letters">ASCII大文字</a>を含まない限り、<a href="#autonomous-custom-element" id="custom-elements-core-concepts:autonomous-custom-element-3">自律カスタム</a>要素上で指定してもよい。例外は<code id="custom-elements-core-concepts:attr-is-3"><a href="#attr-is">is</a></code>属性であり、これは<a href="#autonomous-custom-element" id="custom-elements-core-concepts:autonomous-custom-element-4">自律カスタム要素</a>に指定してはならない（かつ指定しても何の効果もない）。</p>

  <p><a href="#customized-built-in-element" id="custom-elements-core-concepts:customized-built-in-element-2">カスタマイズされた組み込み要素</a>は、それらが拡張する要素に基づいて、属性に関する通常の要件に従う。カスタム属性ベースの動作を追加するには、<code id="custom-elements-core-concepts:attr-data-*"><a href="dom.html#attr-data-*">data-*</a></code>属性を使用する。</p>

  <hr>

  <p><span>フォーム関連</span>フィールドがtrueに設定されている<span>カスタム要素定義</span>に要素が関連付けられている場合、<a href="#autonomous-custom-element" id="custom-elements-core-concepts:autonomous-custom-element-5">自律カスタム要素</a>は<dfn id="form-associated-custom-element" data-export="">フォームに関連付けられたカスタム要素</dfn>と呼ばれる。</p>

  <p><code id="custom-elements-core-concepts:attr-fe-name-2"><a href="form-control-infrastructure.html#attr-fe-name">name</a></code>属性は、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-7">フォームに関連付けられたカスタム要素</a>の名前を表す。<code id="custom-elements-core-concepts:attr-fe-disabled-2"><a href="form-control-infrastructure.html#attr-fe-disabled">disabled</a></code>属性は、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-8">フォームに関連付けられたカスタム要素</a>を非対話的にし、その<a href="#face-submission-value" id="custom-elements-core-concepts:face-submission-value">送信値</a>が送信されないようにするために使用される。<code id="custom-elements-core-concepts:attr-fae-form-2"><a href="form-control-infrastructure.html#attr-fae-form">form</a></code>属性は、<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-9">フォームに関連付けられたカスタム要素</a>をその<a id="custom-elements-core-concepts:form-owner" href="form-control-infrastructure.html#form-owner">フォーム所有者</a>に明示的に関連付けるために使用される。</p>

  <p><a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-10">フォームに関連付けられたカスタム要素</a>の<dfn data-dfn-for="form-associated custom elements" id="attr-face-readonly" data-dfn-type="element-attr"><code>readonly</code></dfn>属性は、要素が<span>制約検証から除外される</span>ことを指定する。ユーザーエージェントはこの属性のための他の動作を提供しないが、カスタム要素の著者は、可能であれば、組み込みフォームコントロール上の<a href="input.html#attr-input-readonly" id="custom-elements-core-concepts:attr-input-readonly">readonly</a>属性の動作と同様に、何らかの適切な方法でコントロールを編集不能にするために、その存在を使用すべきである。</p>

  <p><strong>制約検証</strong>。<a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-11">フォームに関連付けられたカスタム要素</a>に<code id="custom-elements-core-concepts:attr-face-readonly-2"><a href="#attr-face-readonly">readonly</a></code>属性が指定されている場合、その要素は<span>制約検証から除外される</span>。</p>

  <p><a href="#form-associated-custom-element" id="custom-elements-core-concepts:form-associated-custom-element-12">フォームに関連付けられたカスタム要素</a>の<span>リセットアルゴリズム</span>は、要素、コールバック名"<code>formResetCallback</code>"、および空の引数リストをもつ<span>カスタム要素のコールバック反応をキューに加える</span>ことである。</p>

  <hr>

  <p><dfn id="valid-custom-element-name" data-export="">妥当なカスタム要素名</dfn>は、次のすべての要件を満たす一連の文字<var>名</var>である：</p>

  <ul><li><p><var>名前</var>は<code id="custom-elements-core-concepts:prod-potentialcustomelementname"><a href="#prod-potentialcustomelementname">PotentialCustomElementName</a></code>生成物と一致しなければならない：</p>

    <dl><dt><code><dfn id="prod-potentialcustomelementname">PotentialCustomElementName</dfn> ::=</code><dd><code>[a-z] (<a href="#prod-pcenchar" id="custom-elements-core-concepts:prod-pcenchar">PCENChar</a>)* '-' (<a href="#prod-pcenchar" id="custom-elements-core-concepts:prod-pcenchar-2">PCENChar</a>)*</code><dt><code><dfn id="prod-pcenchar">PCENChar</dfn> ::=</code><dd><code>"-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></dl>

    <p>これは、<cite>XML</cite>仕様由来の<a href="http://w4ard.eplusx.net/translation/W3C/REC-xml-20081126/#sec-notation">EBNF notation</a>を使用している。<a href="references.html#refsXML">[XML]</a></p>
   <li><p><var>名前</var>は次のいずれであってはならない：</p>

    <ul class="brief"><li><code>annotation-xml</code><li><code>color-profile</code><li><code>font-face</code><li><code>font-face-src</code><li><code>font-face-uri</code><li><code>font-face-format</code><li><code>font-face-name</code><li><code>missing-glyph</code></ul>

    <p class="note">上記の名前のリストは、<a href="infrastructure.html#other-applicable-specifications" id="custom-elements-core-concepts:other-applicable-specifications">適用可能な仕様</a>、つまり<cite>SVG 2</cite>および<cite>MathML</cite>由来のすべてのハイフンを含む要素名の要約である。<a href="references.html#refsSVG">[SVG]</a> <a href="references.html#refsMATHML">[MATHML]</a></p>
   </ul>

  <div class="note"><p>これらの要件により、<a href="#valid-custom-element-name" id="custom-elements-core-concepts:valid-custom-element-name-2">妥当なカスタム要素名</a>の多数の目標が保証される。</p>

   <ul><li><p>それらは<a id="custom-elements-core-concepts:lowercase-ascii-letters" href="https://triple-underscore.github.io/infra-ja.html#ascii-lower-alpha" data-x-internal="lowercase-ascii-letters">ASCII小文字</a>で開始し、HTMLパーサーがそれらをテキストではなくタグとして扱うことを保証する。<li><p>それらは<a href="https://triple-underscore.github.io/infra-ja.html#ascii-upper-alpha" id="custom-elements-core-concepts:uppercase-ascii-letters-2" data-x-internal="uppercase-ascii-letters">ASCII大文字</a>が含まれないため、ユーザーエージェントは常にHTML要素を大文字・小文字不区別で扱うことができる。<li><p>名前空間および前方互換性を確保するために使用されるハイフンを含む（将来、ハイフンを含むローカル名を持つHTML、SVG、またはMathMLに要素が追加されなくなるため）。<li><p>それらは常に<code id="custom-elements-core-concepts:dom-document-createelement"><a data-x-internal="dom-document-createelement" href="https://triple-underscore.github.io/DOM4-ja.html#dom-document-createelement">createElement()</a></code>および<code id="custom-elements-core-concepts:dom-document-createelementns"><a data-x-internal="dom-document-createelementns" href="https://triple-underscore.github.io/DOM4-ja.html#dom-document-createelementns">createElementNS()</a></code>で作成できるが、これらにはパーサーの制限を超える制限がある。</ul>

   <p>これらの制限とは別に、<code>&lt;math-α></code>や<code>&lt;emotion-😍></code>などのユースケースに最大源の柔軟性を与えるために、さまざまな名前が許可されている。</p>
  </div>

  

  <h4 id="custom-elements-api"><span class="secno">4.13.4</span> <code>CustomElementRegistry</code>インターフェイス<a href="#custom-elements-api" class="self-link"></a></h4><div class="mdn-anno wrapped"><button onclick="toggleStatus(this)" class="mdn-anno-btn"><b title="Support in all current engines." class="all-engines-flag">✔</b><span>MDN</span></button><div class="feature"><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry" title="The CustomElementRegistry interface provides methods for registering custom elements and querying registered elements. To get an instance of it, use the window.customElements property.">CustomElementRegistry</a><p class="all-engines-text">Support in all current engines.<div class="support"><span class="firefox yes"><span>Firefox</span><span>63+</span></span><span class="safari yes"><span>Safari</span><span>10.1+</span></span><span class="chrome yes"><span>Chrome</span><span>54+</span></span><hr><span class="opera unknown"><span>Opera</span><span>?</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge unknown"><span>Edge (Legacy)</span><span>?</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android unknown"><span>Firefox Android</span><span>?</span></span><span class="safari_ios unknown"><span>Safari iOS</span><span>?</span></span><span class="chrome_android unknown"><span>Chrome Android</span><span>?</span></span><span class="webview_android unknown"><span>WebView Android</span><span>?</span></span><span class="samsunginternet_android unknown"><span>Samsung Internet</span><span>?</span></span><span class="opera_android unknown"><span>Opera Android</span><span>?</span></span></div></div></div>

  

  <p class="note">各<a href="#custom-element-constructor" id="custom-elements-api:custom-element-constructor">カスタム要素コンストラクター</a>は<code>HTMLElement</code>インターフェイスを継承しており、<code>Window</code>オブジェクトごとに正確に1 つの<code>HTMLElement</code>インターフェイスが存在するため、カスタム要素レジストリは<code>Document</code> オブジェクトの代わりに、<code>Window</code>オブジェクトに関連付けられる。</p>

  

  <dl class="domintro"><dt><code><var>window</var>.<span>customElements</span>.<span id="dom-customelementregistry-define">define</span>(<var>name</var>, <var>constructor</var>)</code><dd>指定された名前を指定されたコンストラクターに<a href="#autonomous-custom-element" id="custom-elements-api:autonomous-custom-element">自律カスタム要素</a>としてマッピングする、新しい<a href="#custom-element" id="custom-elements-api:custom-element">カスタム要素</a>を定義する。<dt><code><var>window</var>.<span>customElements</span>.<a href="#dom-customelementregistry-define" id="custom-elements-api:dom-customelementregistry-define">define</a>(<var>name</var>, <var>constructor</var>, { extends: <var>baseLocalName</var> })</code><dd>指定された名前を指定されたコンストラクターに、提供された<var>baseLocalName</var>で識別される<a id="custom-elements-api:element-type" href="infrastructure.html#element-type">要素タイプ</a>の<a href="#customized-built-in-element" id="custom-elements-api:customized-built-in-element">カスタマイズされた組み込み要素</a>としてマッピングする、<a href="#custom-element" id="custom-elements-api:custom-element-2">新しいカスタム要素</a>を定義する。<a href="#custom-element" id="custom-elements-api:custom-element-3">カスタム要素</a>または不明な要素を拡張しようとすると、<a id="custom-elements-api:notsupportederror" href="https://webidl.spec.whatwg.org/#notsupportederror" data-x-internal="notsupportederror">"<code>NotSupportedError</code>"</a> <code id="custom-elements-api:domexception"><a data-x-internal="domexception" href="https://webidl.spec.whatwg.org/#dfn-DOMException">DOMException</a></code>が投げられる。<dt><code><var>window</var>.<span>customElements</span>.<span id="dom-customelementregistry-get">get</span>(<var>name</var>)</code><dd>指定された<span>名前</span>に対して定義された<a href="#custom-element-constructor" id="custom-elements-api:custom-element-constructor-2">カスタム要素コンストラクター</a>を回収する。指定された<span>名前</span>の<span>カスタム要素定義</span>がない場合、undefinedを返す。<dt><code><var>window</var>.<span>customElements</span>.<span id="dom-customelementregistry-whendefined">whenDefined</span>(<var>name</var>)</code><dd><a href="#custom-element" id="custom-elements-api:custom-element-5">カスタム要素</a>が指定された名前で定義されたときに<a href="#custom-element" id="custom-elements-api:custom-element-4">カスタム要素</a>のコンストラクターで満たされるプロミスを返す。 （そのような<a href="#custom-element" id="custom-elements-api:custom-element-6">カスタム要素</a>がすでに定義されている場合、返されたプロミスはすぐに満たされる。）<a href="#valid-custom-element-name" id="custom-elements-api:valid-custom-element-name">妥当なカスタム要素名</a>が指定されない場合、 <a id="custom-elements-api:syntaxerror" href="https://webidl.spec.whatwg.org/#syntaxerror" data-x-internal="syntaxerror">"<code>SyntaxError</code>"</a> <code id="custom-elements-api:domexception-2"><a data-x-internal="domexception" href="https://webidl.spec.whatwg.org/#dfn-DOMException">DOMException</a></code>で拒否されたプロミスを返す。<dt><code><var>window</var>.<span>customElements</span>.<span id="dom-customelementregistry-upgrade">upgrade</span>(<var>root</var>)</code><dd>たとえ<a id="custom-elements-api:connected" href="https://triple-underscore.github.io/DOM4-ja.html#connected" data-x-internal="connected">接続されて</a>いないとしても、<var>ルート</var>の<a id="custom-elements-api:shadow-including-inclusive-descendant" href="https://triple-underscore.github.io/DOM4-ja.html#concept-shadow-including-inclusive-descendant" data-x-internal="shadow-including-inclusive-descendant">シャドウを含むすべての子孫</a>要素を<span>アップグレードしようとする</span>。</dl>

  <p><dfn id="element-definition">要素定義</dfn>は、<code>CustomElementRegistry</code>に<span>カスタム要素定義</span>を追加するプロセスである。 これは、<code id="custom-elements-api:dom-customelementregistry-define-2"><a href="#dom-customelementregistry-define">define()</a></code>メソッドによって実現される。</p>

  

  <div class="example"><p><code id="custom-elements-api:dom-customelementregistry-whendefined"><a href="#dom-customelementregistry-whendefined">whenDefined()</a></code>メソッドを使用して、すべての適切な<a href="#custom-element" id="custom-elements-api:custom-element-7">カスタム要素</a>が<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-defined" id="custom-elements-api:concept-element-defined" data-x-internal="concept-element-defined">定義される</a>まで、アクションを実行しないようにすることができる。この例において、使用する<a href="#autonomous-custom-element" id="custom-elements-api:autonomous-custom-element-2">自律カスタム要素</a>のすべてが定義されるまで、動的に読み込まれる記事のコンテンツを非表示するために、それを<code>:defined</code>疑似クラスと組み合わる。</p>

   <pre><code class='js'>articleContainer<c- p>.</c->hidden <c- o>=</c-> <c- kc>true</c-><c- p>;</c->

fetch<c- p>(</c->articleURL<c- p>)</c->
  <c- p>.</c->then<c- p>(</c->response <c- p>=></c-> response<c- p>.</c->text<c- p>())</c->
  <c- p>.</c->then<c- p>(</c->text <c- p>=></c-> <c- p>{</c->
    articleContainer<c- p>.</c->innerHTML <c- o>=</c-> text<c- p>;</c->

    <c- k>return</c-> Promise<c- p>.</c->all<c- p>(</c->
      <c- p>[...</c->articleContainer<c- p>.</c->querySelectorAll<c- p>(</c-><c- u>":not(:defined)"</c-><c- p>)]</c->
        <c- p>.</c->map<c- p>(</c->el <c- p>=></c-> customElements<c- p>.</c->whenDefined<c- p>(</c->el<c- p>.</c->localName<c- p>))</c->
    <c- p>);</c->
  <c- p>})</c->
  <c- p>.</c->then<c- p>(()</c-> <c- p>=></c-> <c- p>{</c->
    articleContainer<c- p>.</c->hidden <c- o>=</c-> <c- kc>false</c-><c- p>;</c->
  <c- p>});</c-></code></pre>
  </div>

  

  <div class="example"><p><code id="custom-elements-api:dom-customelementregistry-upgrade"><a href="#dom-customelementregistry-upgrade">upgrade()</a></code>メソッドは、自由に要素をアップグレード可能にする。 通常、要素は<a id="custom-elements-api:connected-2" href="https://triple-underscore.github.io/DOM4-ja.html#connected" data-x-internal="connected">接続された</a>ときに自動的にアップグレードされるが、この方法は、要素を接続する準備ができる前にアップグレードする必要がある場合に使用できる。</p>

   <pre><code class='js'><c- a>const</c-> el <c- o>=</c-> document<c- p>.</c->createElement<c- p>(</c-><c- u>"spider-man"</c-><c- p>);</c->

<c- a>class</c-> SpiderMan <c- k>extends</c-> HTMLElement <c- p>{}</c->
customElements<c- p>.</c->define<c- p>(</c-><c- u>"spider-man"</c-><c- p>,</c-> SpiderMan<c- p>);</c->

console<c- p>.</c->assert<c- p>(</c-><c- o>!</c-><c- p>(</c->el <c- k>instanceof</c-> SpiderMan<c- p>));</c-> <c- c1>// not yet upgraded</c->

customElements<c- p>.</c->upgrade<c- p>(</c->el<c- p>);</c->
console<c- p>.</c->assert<c- p>(</c->el <c- k>instanceof</c-> SpiderMan<c- p>);</c->    <c- c1>// upgraded!</c-></code></pre>
  </div>

  

  <h4 id="custom-element-reactions"><span class="secno">4.13.5</span> カスタム要素応答<a href="#custom-element-reactions" class="self-link"></a></h4>

  <p><a href="#custom-element" id="custom-element-reactions:custom-element">カスタム要素</a>は、著者のコードを実行することで特定の出来事に応答する機能がある：</p>

  <ul><li><p><span>アップグレードされる</span>と、引数なしでその<a href="#custom-element-constructor" id="custom-element-reactions:custom-element-constructor">コンストラクター</a>は実行される。<li><p><a id="custom-element-reactions:becomes-connected" href="infrastructure.html#becomes-connected">接続される</a>と、<code>connectedCallback</code>は引数なしで呼び出される。<li><p><a id="custom-element-reactions:becomes-disconnected" href="infrastructure.html#becomes-disconnected">接続が切断される</a>と、その<code>disconnectCallCallback</code>は引数なしで呼び出される。<li><p>新しい文書に<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-node-adopt" id="custom-element-reactions:concept-node-adopt" data-x-internal="concept-node-adopt">採用される</a>と、古い文書と新しい文書を引数として指定して、<code>adoptedCallback</code>が呼び出される。<li><p>属性のいずれかが<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-attributes-change" id="custom-element-reactions:concept-element-attributes-change" data-x-internal="concept-element-attributes-change">変更</a>、<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-attributes-append" id="custom-element-reactions:concept-element-attributes-append" data-x-internal="concept-element-attributes-append">追加</a>、<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-attributes-remove" id="custom-element-reactions:concept-element-attributes-remove" data-x-internal="concept-element-attributes-remove">削除</a>、または<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-element-attributes-replace" id="custom-element-reactions:concept-element-attributes-replace" data-x-internal="concept-element-attributes-replace">置換</a>されるとき、属性のローカル名、古い値、新しい値、および名前空間が引数として指定され、<code>attributeChangedCallback</code>が呼び出される。（属性の古い値または新しい値は、その属性が追加または削除されたときにそれぞれnullと見なされる。）<li><p>ユーザーエージェントが<a href="#form-associated-custom-element" id="custom-element-reactions:form-associated-custom-element">フォームに関連付けられたカスタム要素</a>の<span>フォーム所有者をリセットし</span>、それによってフォーム所有者を変更するとき、引数として新しいフォーム所有者（所有者がいない場合はnull）が指定されて、その<code>formAssociatedCallback</code>が呼び出される。<li><p><a href="#form-associated-custom-element" id="custom-element-reactions:form-associated-custom-element-2">フォームに関連付けられたカスタム要素</a>のフォーム所有者が<span>リセット</span>されるとき、その<code>formResetCallback</code>が呼び出される。<li><p><a href="#form-associated-custom-element" id="custom-element-reactions:form-associated-custom-element-3">フォームに関連付けられたカスタム要素</a>の<a href="form-control-infrastructure.html#concept-fe-disabled" id="custom-element-reactions:concept-fe-disabled">無効</a>状態が変更されるとき、新しい状態が引数として指定され、その<code>formDisabledCallback</code>が呼び出される。<li><p>ユーザーエージェントがユーザーに代わって、または<span>ナビゲーションの一部</span>として<a href="#form-associated-custom-element" id="custom-element-reactions:form-associated-custom-element-4">フォームに関連付けられたカスタム要素</a>の値を更新するとき、新しい値と理由を示す文字列"<code>autocomplete</code>"または"<code>restore</code>"を引数として指定して、その<code>formStateRestoreCallback</code>が呼び出される。</ul>

  <p>これらの反応をまとめて<dfn id="concept-custom-element-reaction">カスタム要素応答</dfn>と呼ぶ。</p>

  <p><a href="#concept-custom-element-reaction" id="custom-element-reactions:concept-custom-element-reaction">カスタム要素反応</a>が呼び出される方法は、デリケートな操作の途中で著者のコードが実行されるのを避けるために、特別な注意を払って行われる。実質的に、"ユーザースクリプトに戻る直前"まで遅延される。これは、ほとんどの目的では同期して実行されているように見えるが、複雑な複合操作（<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-node-clone" id="custom-element-reactions:concept-node-clone" data-x-internal="concept-node-clone">クローニング</a>や<a href="https://triple-underscore.github.io/DOM4-ja.html#concept-range" id="custom-element-reactions:concept-range" data-x-internal="concept-range">範囲</a>操作など）の場合は、すべての関連するユーザーエージェントの処理ステップが完了するまで遅延され、その後、バッチとしてまとめて実行されることを意味する。</p>

  <p><a href="#concept-custom-element-reaction" id="custom-element-reactions:concept-custom-element-reaction-2">カスタム要素反応</a>は常に、少なくとも1つの<a href="#custom-element" id="custom-element-reactions:custom-element-2">カスタム要素</a>のローカルコンテキスト内で、トリガーアクションと同じ順序で呼び出されることが<span>保証されている</span>。（<a href="#concept-custom-element-reaction" id="custom-element-reactions:concept-custom-element-reaction-3">カスタム要素反応</a>コードは独自の変更を実行できるため、複数の要素にまたがるグローバルな順序付けを保証することはできない。）</p>

  

  <h4 id="element-internals"><span class="secno">4.13.6</span> 要素内部<a href="#element-internals" class="self-link"></a></h4>

  <p>特定の機能は、カスタム要素の作成者が利用可能であることを意図されているが、カスタム要素の利用者は意図されていない。これらは、<code id="element-internals:dom-attachinternals"><a href="#dom-attachinternals">element.attachInternals()</a></code>メソッドによって提供され、<code>ElementInternals</code>のインスタンスを返す。<code>ElementInternals</code>のプロパティおよびメソッドは、ユーザーエージェントがすべての要素に提供する内部機能の制御を可能にする。</p>

  <dl class="domintro"><dt><code><var>element</var>.<span id="dom-attachinternals">attachInternals()</span></code><div class="mdn-anno wrapped before"><button onclick="toggleStatus(this)" class="mdn-anno-btn"><span>MDN</span></button><div class="feature"><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/attachInternals" title="The HTMLElement.attachInternals() method returns an ElementInternals object. This method allows a custom element to participate in HTML forms. The ElementInternals interface provides utilities for working with these elements in the same way you would work with any standard HTML form element, and also exposes the Accessibility Object Model to the element.">HTMLElement/attachInternals</a><div class="support"><span class="firefox yes"><span>Firefox</span><span>93+</span></span><span class="safari no"><span>Safari</span><span>No</span></span><span class="chrome yes"><span>Chrome</span><span>77+</span></span><hr><span class="opera unknown"><span>Opera</span><span>?</span></span><span class="edge_blink yes"><span>Edge</span><span>79+</span></span><hr><span class="edge unknown"><span>Edge (Legacy)</span><span>?</span></span><span class="ie no"><span>Internet Explorer</span><span>No</span></span><hr><span class="firefox_android unknown"><span>Firefox Android</span><span>?</span></span><span class="safari_ios unknown"><span>Safari iOS</span><span>?</span></span><span class="chrome_android unknown"><span>Chrome Android</span><span>?</span></span><span class="webview_android unknown"><span>WebView Android</span><span>?</span></span><span class="samsunginternet_android unknown"><span>Samsung Internet</span><span>?</span></span><span class="opera_android unknown"><span>Opera Android</span><span>?</span></span></div></div></div><dd><p><a href="#custom-element" id="element-internals:custom-element">カスタム要素</a><var>element</var>をターゲットとする<code>ElementInternals</code>オブジェクトを返す。<var>element</var>が<a href="#custom-element" id="element-internals:custom-element-2">カスタム要素</a>でない場合、"<code>internals</code>"機能が要素定義の一部として無効にされた場合、または同じ要素で2回呼び出された場合、例外を投げる。</dl>

  

  <h5 id="shadow-root-access"><span class="secno">4.13.6.1</span> シャドウルートアクセス<a href="#shadow-root-access" class="self-link"></a></h5>

  <dl class="domintro"><dt><code><var>internals</var>.<span>shadowRoot</span></code><dd><p><span>ターゲット要素</span>が<a id="shadow-root-access:shadow-host" href="https://triple-underscore.github.io/DOM4-ja.html#element-shadow-host" data-x-internal="shadow-host">シャドウホスト</a>である場合、 <var>internals</var>の<span>ターゲット要素</span>の<code id="shadow-root-access:shadowroot"><a data-x-internal="shadowroot" href="https://triple-underscore.github.io/DOM4-ja.html#interface-shadowroot">ShadowRoot</a></code>を返し、そうでなければnullを返す。</dl>

  

  <h5 id="form-associated-custom-elements"><span class="secno">4.13.6.2</span> フォームに関連付けられたカスタム要素<a href="#form-associated-custom-elements" class="self-link"></a></h5>

  <dl class="domintro"><dt><code><var>internals</var>.<span>setFormValue</span>(<var>value</var>)</code><dd><p><var>internals</var>の<span>ターゲット要素</span>の<a href="#face-state" id="form-associated-custom-elements:face-state">状態</a>と<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value">送信値</a>の両方を<var>value</var>に設定する。</p>

    <p><var>value</var>がnullである場合、要素はフォームの送信に参加しない。</p>
   <dt><code><var>internals</var>.<span>setFormValue</span>(<var>value</var>, <var>state</var>)</code><dd><p><var>internals</var>の<span>ターゲット要素</span>の<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-2">送信値</a>を<var>value</var>に設定し、その<a href="#face-state" id="form-associated-custom-elements:face-state-2">状態</a>を<var>state</var>に設定する。</p>

    <p><var>value</var>がnullである場合、要素はフォームの送信に参加しない。</p>
   <dt><code><var>internals</var>.<span>form</span></code><dd><p><var>internals</var>の<span>ターゲット要素</span>の<a id="form-associated-custom-elements:form-owner" href="form-control-infrastructure.html#form-owner">フォーム所有者</a>を返す。<dt><code><var>internals</var>.<span>setValidity</span>(<var>flags</var>, <var>message</var> [, <var>anchor</var> ])</code><dd><p><var>internals</var>の<span>ターゲット要素</span>を<var>flags</var>引数で示された制約の影響を受けるものとしてマークし、要素の検証メッセージを<var>message</var>に設定する。<var>anchor</var>が指定される場合、ユーザーエージェントは、<a id="form-associated-custom-elements:form-owner-2" href="form-control-infrastructure.html#form-owner">フォームの所有者</a>がインタラクティブに検証される、または<code>reportValidity()</code>が呼び出されたときに、<var>internals</var>の<span>ターゲット要素</span>の制約に関する問題を示すために使用することがある。<dt><code><var>internals</var>.<span>setValidity</span>({})</code><dd><p><var>internals</var>の<span>ターゲット要素</span>を<span>その制約を満たす</span>ものとしてマークする。<dt><code><var>internals</var> . <span>willValidate</span></code><dd><p>フォームの送信時に<var>internals</var>の<span>ターゲット要素</span>が検証される場合はtrueを返す。そうでなけれればfalseを返す。<dt><code><var>internals</var>.<span>validity</span></code><dd><p><var>internals</var>の<span>ターゲット要素</span>の<code>ValidityState</code>オブジェクトを返す。<dt><code><var>internals</var> . <span>validationMessage</span></code><dd><p>もし<var>internals</var>の<span>ターゲット要素</span>の妥当性をチェックしたならば、ユーザーに表示されるエラーメッセージを返すだろう。<dt><code><var>valid</var> = <var>internals</var> . <span>checkValidity()</span></code><dd><p><var>internals</var>の<span>ターゲット要素</span>に妥当性の問題がない場合はtrueを返す。 そうでなければfalseを返す。 後者の場合要素で<code id="form-associated-custom-elements:event-invalid"><a href="indices.html#event-invalid">invalid</a></code>イベントを発火する。<dt><code><var>valid</var> = <var>internals</var> . <span>reportValidity()</span></code><dd><p><var>internals</var>の<span>ターゲット要素</span>が一切妥当性の問題を持たない場合はtrueを返す。そうでなければfalseを返し、要素で<code id="form-associated-custom-elements:event-invalid-2"><a href="indices.html#event-invalid">invalid</a></code>イベントを発火させ、そして（イベントが中止されない場合）ユーザーに問題を報告する。<dt><code><var>internals</var>.<span>labels</span></code><dd><p><var>internals</var>の<span>ターゲット要素</span>が関連付けられているすべての<code id="form-associated-custom-elements:the-label-element"><a href="forms.html#the-label-element">label</a></code> 要素の<code id="form-associated-custom-elements:nodelist"><a data-x-internal="nodelist" href="https://triple-underscore.github.io/DOM4-ja.html#interface-nodelist">NodeList</a></code>を返す。</dl>

  <p>それぞれの<a href="#form-associated-custom-element" id="form-associated-custom-elements:form-associated-custom-element">フォームに関連付けられたカスタム要素</a>は<dfn id="face-submission-value">送信値</dfn>を持つ。フォーム送信時に1つ以上の<span>エントリー</span>を提供するために使用される。<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-3">送信値</a>の初期値はnullであり、<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-4">送信値</a>はnull、文字列、<code id="form-associated-custom-elements:file"><a data-x-internal="file" href="https://triple-underscore.github.io/File_API-ja.html#dfn-file">File</a></code>、または<span>エントリー</span>の<a id="form-associated-custom-elements:list" href="https://triple-underscore.github.io/infra-ja.html#list" data-x-internal="list">リスト</a>にすることができる。</p>

  <p>それぞれの<a href="#form-associated-custom-element" id="form-associated-custom-elements:form-associated-custom-element-2">フォームに関連付けられたカスタム要素</a>は<dfn id="face-state">状態</dfn>を持つ。これは、ユーザーエージェントが要素に対するユーザーの入力を復元できる情報である。<a href="#face-state" id="form-associated-custom-elements:face-state-3">状態</a>の初期値はnullであり、<a href="#face-state" id="form-associated-custom-elements:face-state-4">状態</a>はnull、文字列、<code id="form-associated-custom-elements:file-2"><a data-x-internal="file" href="https://triple-underscore.github.io/File_API-ja.html#dfn-file">File</a></code>,、または<span>エントリー</span>の<a id="form-associated-custom-elements:list-2" href="https://triple-underscore.github.io/infra-ja.html#list" data-x-internal="list">リスト</a>にすることができる。</p>

  <p>カスタム要素の著者は<code>setFormValue()</code>メソッドを使用して要素の<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-5">送信値</a>と<a href="#face-state" id="form-associated-custom-elements:face-state-5">状態</a>を設定し、これらをユーザーエージェントに伝達する。</p>

  <p>ユーザーエージェントが、たとえば<span>ナビゲーション後</span>やユーザーエージェントの再起動など、<a href="#form-associated-custom-element" id="form-associated-custom-elements:form-associated-custom-element-3">フォームに関連付けられたカスタム要素</a>の<a href="#face-state" id="form-associated-custom-elements:face-state-6">状態</a>を復元するのがよいと考えている場合、その要素、コールバック名"<code>formStateRestoreCallback</code>"、復元する状態を含む引数リスト、および<code>"restore"</code>をもつ<span>カスタム要素のコールバック反応をエンキュー</span>してもよい。</p>

  <p>ユーザーエージェントがフォーム記入アシスト機能を持っている場合、その機能が呼び出されたときに、<a href="#form-associated-custom-element" id="form-associated-custom-elements:form-associated-custom-element-4">フォームに関連付けられたカスタム要素</a>、コールバック名"<code>formStateRestoreCallback</code>"、状態値の履歴といくつかのヒューリスティックによって決定された状態値を含む引数リスト、および<code>"autocomplete"</code>とともに<span>フォームに関連付けられたカスタム要素のコールバック反応をエンキュー</span>してもよい。</p>

  <p>一般に、<a href="#face-state" id="form-associated-custom-elements:face-state-7">状態</a>はユーザーによって指定された情報であり、<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-6">送信値</a>はサーバーへの送信に適した、正規化またはサニタイズ後の値である。 次の例は、これを具体的に示している：</p>

  <p class="example">ユーザーに日付の指定を求める<a href="#form-associated-custom-element" id="form-associated-custom-elements:form-associated-custom-element-5">フォームに関連付けられたカスタム要素</a>があるとする。 ユーザーは<kbd>"3/15/2019"</kbd>を指定するが、コントロールはサーバーに<code>"2019-03-15"</code>を送信しようとする。<kbd>"3/15/2019"</kbd>は要素の<a href="#face-state" id="form-associated-custom-elements:face-state-8">状態</a>であり、<code>"2019-03-15"</code>は<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-7">送信値</a>である。</p>

  <p class="example">既存の<a href="input.html#checkbox-state-(type=checkbox)" id="form-associated-custom-elements:checkbox-state-(type=checkbox)">チェックボックス</a><code id="form-associated-custom-elements:the-input-element"><a href="input.html#the-input-element">input</a></code>タイプの動作をエミュレートするカスタム要素を開発するとする。 その<a href="#face-submission-value" id="form-associated-custom-elements:face-submission-value-8">送信値</a>は、その<code>value</code>コンテンツ属性の値、または文字列<code>"on"</code>になる。その<a href="#face-state" id="form-associated-custom-elements:face-state-9">状態</a>は、<code>"checked"</code>、<code>"unchecked"</code>、<code>"checked/indeterminate"</code>、または<code>"unchecked/indeterminate"</code>のいずれかになる。</p>

  

  <h5 id="accessibility-semantics"><span class="secno">4.13.6.3</span> アクセシビリティセマンティックス<a href="#accessibility-semantics" class="self-link"></a></h5>

  <dl class="domintro"><dt><code><var>internals</var>.<span><a href="#dom-ElementInternals-accessibility-idl-get">role</a></span> [ = <var>value</var> ]</code><dd><p><var>internals</var>の<span>ターゲット要素</span>のデフォルトのARIAロールを設定または取得する。これは、ページの著者が<code id="accessibility-semantics:attr-aria-role"><a href="infrastructure.html#attr-aria-role">role</a></code>属性を使用して上書きしない限り、使用される。<dt><code><var>internals</var>.<span><a href="#dom-ElementInternals-accessibility-idl-get">aria*</a></span> [ = <var>value</var> ]</code><dd><p><var>internals</var>の<span>ターゲット要素</span>のさまざまなデフォルトのARIAステートまたはプロパティを設定または取得する。これは、ページの著者が<code id="accessibility-semantics:attr-aria-*"><a href="infrastructure.html#attr-aria-*">aria-*</a></code>属性を使用してそれらを上書きしない限り、使用される。</dl>

  <p><code>ElementInternals</code>の<code>role</code>および<code>aria*</code>プロパティを使用することで、カスタム要素の著者は、ネイティヴ要素がどのように振る舞うかに類似の、カスタム要素にデフォルトのアクセシブルなロール、ステート、およびプロパティ値を設定することができる。詳細は<a href="#custom-elements-accessibility-example">上記の例</a>を参照のこと。</p>

  

  <nav><a href="canvas.html">← 4.12.5 canvas要素</a> – <a href="./">目次</a> – <a href="semantics-other.html">4.14 専用要素なしの一般的語彙 →</a></nav>
