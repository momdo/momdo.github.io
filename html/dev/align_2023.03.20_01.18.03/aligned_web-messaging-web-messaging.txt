HTML: The Living Standard	HTML:The Living Standard(HTML:生活水準)	web-messaging
← 9.2 Server-sent events — Table of Contents — 10 Web workers →	←9.2サーバ送信イベント-目次 10 ウェブワーカー→	web-messaging
9.3 Cross-document messaging	9.3 ドキュメント間のメッセージング	web-messaging
9.3.1 Introduction	9.3.1 はじめに	web-messaging
9.3.2 Security	9.3.2 セキュリティ	web-messaging
9.3.3 Posting messages	9.3.3 メッセージの投稿	web-messaging
9.4 Channel messaging	9.4 チャンネルメッセージング	web-messaging
9.4.1 Introduction	9.4.1 はじめに	web-messaging
9.4.1.1 Examples	9.4.1.1例	web-messaging
9.4.1.2 Ports as the basis of an object-capability model on the web	9.4.1.2 ウェブ上のオブジェクト機能モデルの基礎としてのポート	web-messaging
9.4.1.3 Ports as the basis of abstracting out service implementations	9.4.1.3 サービス実装を抽象化する基礎としてのポート	web-messaging
9.4.2 Message channels	9.4.2 メッセージチャンネル	web-messaging
9.4.3 Message ports	9.4.3 メッセージポート	web-messaging
9.4.4 Broadcasting to many ports	9.4.4 多数のポートへのブロードキャスト	web-messaging
9.4.5 Ports and garbage collection	9.4.5 ポートとガベージコレクション	web-messaging
9.5 Broadcasting to other browsing contexts 	9.5 他のブラウジングコンテキストへのブロードキャスト 	web-messaging
9.3 Cross-document messaging	9.3 文書間のメッセージング	web-messaging
Web browsers, for security and privacy reasons, prevent documents in different domains from affecting each other; that is, cross-site scripting is disallowed.	ウェブブラウザーは、セキュリティおよびプライバシー上の理由から、異なるドメインの文書が互いに影響を及ぼすことを防止している。つまり、クロスサイトスクリプティングは禁止されている。 	web-messaging
While this is an important security feature, it prevents pages from different domains from communicating even when those pages are not hostile.	これは重要なセキュリティ機能であるが、異なるドメインのページが敵対的でない場合でも、それらのページが通信するのを防ぐ。	web-messaging
This section introduces a messaging system that allows documents to communicate with each other regardless of their source domain, in a way designed to not enable cross-site scripting attacks.	このセクションでは、クロスサイトスクリプティング攻撃を可能にしないように設計された方法で、ソースのドメインに関係なく文書が相互に通信できるようにするメッセージングシステムを導入する。 	web-messaging
The postMessage() API can be used as a tracking vector.	postMessage() APIは トラッキングベクターである。 	web-messaging
For example, if document A contains an iframe element that contains document B, and script in document A calls postMessage() on the Window object of document B, then a message event will be fired on that object, marked as originating from the Window of document A.	たとえば、文書Aが文書Bを含むiframe要素を含み、かつ文書A内のスクリプトが文書BのWindowオブジェクトのpostMessage()を呼ぶ場合、文書AのWindowから生じたとマークされる、そのオブジェクトに対してメッセージイベントが発火する。	web-messaging
The script in document A might look like:	文書Aのスクリプトは次のようになる：	web-messaging
To register an event handler for incoming events, the script would use addEventListener() (or similar mechanisms).	着信イベントのイベントハンドラーを登録するには、スクリプトはaddEventListener()（または同様のメカニズム）を使用する。 	web-messaging
For example, the script in document B might look like:	たとえば、文書Bのスクリプトは次のようになる。 	web-messaging
This script first checks the domain is the expected domain, and then looks at the message, which it either displays to the user, or responds to by sending a message back to the document which sent the message in the first place.	このスクリプトは、最初にドメインが予期されたドメインであるかどうかをチェックし、次にメッセージを確認する。これは、メッセージがユーザーに表示されるか、最初にメッセージを送信した文書にメッセージを返信することで応答するかのいずれかである。 	web-messaging
9.3.2 Security	9.3.2 セキュリティ	web-messaging
Use of this API requires extra care to protect users from hostile entities abusing a site for their own purposes.	このAPIを使用するには、悪意のあるエンティティが自分の目的のためにサイトを悪用することからユーザーを保護するための特別な注意を必要とする。	web-messaging
Authors should check the origin attribute to ensure that messages are only accepted from domains that they expect to receive messages from.	著者は、メッセージを受信することが予想されるドメインからのメッセージのみが受け入れられるようにorigin属性をチェックすべきである。	web-messaging
Otherwise, bugs in the author's message handling code could be exploited by hostile sites.	そうでなければ、著者のメッセージ処理コードのバグが悪意のあるサイトによって悪用される可能性がある。	web-messaging
Furthermore, even after checking the origin attribute, authors should also check that the data in question is of the expected format.	さらに、origin属性を確認した後でも、著者は、問題のデータが想定された形式であることも確認すべきである。	web-messaging
Otherwise, if the source of the event has been attacked using a cross-site scripting flaw, further unchecked processing of information sent using the postMessage() method could result in the attack being propagated into the receiver.	そうでなければ、イベントのソースがクロスサイトスクリプティングの欠陥を使用して攻撃された場合、postMessage()メソッドを使用して送信された情報の未チェックの処理がさらに行われると、攻撃が受信者に伝播される可能性がある。	web-messaging
Authors should not use the wildcard keyword (*) in the targetOrigin argument in messages that contain any confidential information, as otherwise there is no way to guarantee that the message is only delivered to the recipient to which it was intended.	著者は、秘密情報を含むメッセージのtargetOrigin引数にワイルドカードキーワード（*）を使用すべきでない。それ以外の場合は、メッセージが意図された受信者にのみ配信されることを保証する方法はない。	web-messaging
Authors who accept messages from any origin are encouraged to consider the risks of a denial-of-service attack.	すべての生成元からのメッセージを受け入れる著者は、サービス拒否攻撃のリスクを考慮することが勧められる。	web-messaging
An attacker could send a high volume of messages; if the receiving page performs expensive computation or causes network traffic to be sent for each such message, the attacker's message could be multiplied into a denial-of-service attack.	攻撃者は大量のメッセージを送信する可能性がある。受信ページが高価な計算を実行したり、そのようなメッセージごとにネットワークトラフィックを送信させたりすると、攻撃者のメッセージがサービス拒否攻撃に増幅される可能性があります。	web-messaging
Authors are encouraged to employ rate limiting (only accepting a certain number of messages per minute) to make such attacks impractical.	作成者は、このような攻撃を非実用的にするために、レート制限(1分あたり特定の数のメッセージのみを受け入れる)を使用することが推奨されます。 	web-messaging
9.3.3 Posting messages	9.3.3メッセージの投稿	web-messaging
Posts a message to the given window.	指定されたウィンドウにメッセージをポストする。	web-messaging
Messages can be structured objects, e.g. nested objects and arrays, can contain JavaScript values (strings, numbers, Date objects, etc.), and can contain certain data objects such as File Blob , FileList , and ArrayBuffer objects.	メッセージは、ネストされたオブジェクトや配列などの構造化オブジェクトとなることができ、JavaScript値（文字列、数値、日付オブジェクトなど）を含むことができ、ならびにFile Blob、FileList 、およびArrayBufferオブジェクトのような特定のデータオブジェクトを含むことができる。	web-messaging
Objects listed in the transfer member of options are transferred, not just cloned, meaning that they are no longer usable on the sending side.	オプションの移送 メンバーに一覧表示されるオブジェクトは、クローンではなく転送され、これは送信側では使用できなくなりますことを意味する。 	web-messaging
A target origin can be specified using the targetOrigin member of options . If not provided, it defaults to " / ".	ターゲット生成元は、オプションのtargetOriginメンバーを指定できる。指定しない場合、デフォルトは"/"である。	web-messaging
This default restricts the message to same-origin targets only.	このデフォルトでは、メッセージは同一生成元ターゲットだけに制限される。	web-messaging
If the origin of the target window doesn't match the given target origin, the message is discarded, to avoid information leakage.	ターゲットウィンドウの生成元が指定されたターゲット生成元と一致しない場合、情報の漏洩を回避するためにメッセージは破棄される。	web-messaging
To send the message to the target regardless of origin, set the target origin to " * ".	生成元に関係なくターゲットにメッセージを送信するためには、ターゲット生成元を"*"に設定する。	web-messaging
Throws a " DataCloneError " DOMException if transfer array contains duplicate objects or if message could not be cloned.	移送配列に重複するオブジェクトを含む場合、またはメッセージがクローンされなかった場合、"DataCloneError" DOM例外を投げる。	web-messaging
This is an alternate version of postMessage() where the target origin is specified as a parameter.	これは postMessage()の代替バージョンであり、ここで、ターゲット生成元はパラメータとして指定される。	web-messaging
Calling window.postMessage(message, target, transfer) is equivalent to window.postMessage(message, {targetOrigin, transfer}) .	window.postMessage(message, target, transfer)を呼ぶことは、window.postMessage(message, {targetOrigin, transfer})と等価である。	web-messaging
When posting a message to a Window of a browsing context that has just been navigated to a new Document is likely to result in the message not receiving its intended recipient: the scripts in the target browsing context have to have had time to set up listeners for the messages.	新しいDocumentに移動したばかりのブラウジングコンテキストのWindowにメッセージを投稿するとき、メッセージが目的の受信者を受信しない可能性がある。ターゲットブラウジングコンテキストのスクリプトには、メッセージのリスナーを設定する時間が必要である。 	web-messaging
Thus, for instance, in situations where a message is to be sent to the Window of newly created child iframe , authors are advised to have the child Document post a message to their parent announcing their readiness to receive messages, and for the parent to wait for this message before beginning posting messages.	したがって、たとえば、新しく作成された子iframeのWindowにメッセージが送信される状況では、著者は、子Documentがメッセージを受信する準備ができたことを知らせるメッセージを親ドキュメントに投稿し、親ドキュメントがこのメッセージを待ってからメッセージの投稿を開始するようにすることを勧める。 	web-messaging
9.4 Channel messaging	9.4 チャネル・メッセージング	web-messaging
9.4.1 Introduction	9.4.1 はじめに	web-messaging
To enable independent pieces of code (e.g. running in different browsing contexts) to communicate directly, authors can use channel messaging.	独立したコードの部分（たとえば異なるブラウジングコンテキストで実行する）が直接通信することを可能にするために、著者はチャンネルメッセージングを使用できる。 	web-messaging
Communication channels in this mechanism are implemented as two-ways pipes, with a port at each end.	このメカニズムの通信チャンネルは、両端にポートをもつ2方向のパイプとして実装される。	web-messaging
Messages sent in one port are delivered at the other port, and vice-versa.	一方のポートで送信されたメッセージは他方のポートに配信され、その逆も同様である。	web-messaging
Messages are delivered as DOM events, without interrupting or blocking running tasks.	メッセージはDOMイベントとして配信され、タスクの実行を中断またはブロックすることはない。 	web-messaging
To create a connection (two "entangled" ports), the MessageChannel() constructor is called:	接続（2つの”もつれた”ポート）を作成するには、MessageChannel()コンストラクターは以下のように呼ばれる： 	web-messaging
One of the ports is kept as the local port, and the other port is sent to the remote code, e.g. using postMessage() :	ポートの1つはローカルポートとして保持され、using postMessage()などを用いてもう1つのポートはリモートコードに送信される：	web-messaging
To send messages, the postMessage() method on the port is used:	メッセージを送信するには、postMessage()メソッドが使用される：	web-messaging
To receive messages, one listens to message events:	メッセージを受信するには、メッセージイベントをリッスンする：	web-messaging
Data sent on a port can be structured data; for example here an array of strings is passed on a MessagePort :	ポートで送信されるデータは、構造化されたデータかもしれない。たとえば、ここでは文字列の配列が MessagePortである：	web-messaging
9.4.1.1 Examples	9.4.1.1 例	web-messaging
In this example, two JavaScript libraries are connected to each other using MessagePort s.	この例では、2つのJavaScriptライブラリーがMessagePortを用いて互いに接続される。	web-messaging
This allows the libraries to later be hosted in different frames, or in Worker objects, without any change to the APIs.	これは、APIを変更することなく、後でライブラリーを異なるフレームまたはワーカーオブジェクトでホストすることを可能にする。	web-messaging
Here's what the "addContactsProvider()" function's implementation could look like:	“addContactsProvider()”関数の実装は次のようになる：	web-messaging
Alternatively, it could be implemented as follows:	または、次のように実装することもできる：	web-messaging
The key difference is that when using addEventListener() , the start() method must also be invoked.	主な違いは、addEventListener()を使用する場合、start()メソッドも呼び出さなければならないことにある。	web-messaging
When using onmessage , the call to start() is implied.	onmessageを用いる場合、start()の呼び出しは暗黙的である。	web-messaging
The start() method, whether called explicitly or implicitly (by setting onmessage ), starts the flow of messages: messages posted on message ports are initially paused, so that they don't get dropped on the floor before the script has had a chance to set up its handlers.	start()メソッドは、（onmessageを設定することで）明示的にまたは暗黙的に呼び出されても、メッセージのフローを開始する。メッセージポートに投稿されたメッセージは、スクリプトがハンドラーを設定する前にフロアに落とされないように、最初は一時停止される。 	web-messaging
		web-messaging
9.4.1.2 Ports as the basis of an object-capability model on the web	9.4.1.2Web上のオブジェクト機能モデルの基礎としてのポート	web-messaging
Ports can be viewed as a way to expose limited capabilities (in the object-capability model sense) to other actors in the system.	ポートは、システム内の他のアクターに対して（オブジェクト機能モデルの意味で）制限された機能を公開する方法と見なすことができる。	web-messaging
This can either be a weak capability system, where the ports are merely used as a convenient model within a particular origin, or as a strong capability model, where they are provided by one origin provider as the only mechanism by which another origin consumer can effect change in or obtain information from provider .	これは、ポートが特定のオリジン内の便利なモデルとしてのみ使用される弱い機能システムか、ポートが1つのオリジンによって提供される強い機能モデルのいずれかです。	web-messaging
For example, consider a situation in which a social web site embeds in one iframe the user's email contacts provider (an address book site, from a second origin), and in a second iframe a game (from a third origin).	提供者 唯一のメカニズムとして 消費者 変化をもたらすか、情報を得ることができる 提供者 です。	web-messaging
The outer social site and the game in the second iframe cannot access anything inside the first iframe ; together they can only:	 たとえば、ソーシャルWebサイトが iframeユーザーのEメール連絡先プロバイダ(第2の発信元からのアドレス帳サイト) iframeゲーム(第3の起源から)。	web-messaging
Navigate the iframe to a new URL, such as the same URL but with a different fragment, causing the Window in the iframe to receive a hashchange event.	外部のソーシャルサイトと2番目のゲーム iframe[イメージフレーム] 1番目の iframe[イメージフレーム] ;これらを一緒に使用すると、次のことだけが	web-messaging
Resize the iframe , causing the Window in the iframe to receive a resize event.	ナビゲートと iframe[イメージフレーム] 新しい ≪URLURLemdwなど)。	web-messaging
		web-messaging
		web-messaging
Send a message event to the Window in the iframe using the window.postMessage() API.	 送信 メッセージ イベントを 窓 領域の iframe[イメージフレーム] を使用して window.postMessage()[ウィンドウ.ポストメッセージ] API。	web-messaging
The contacts provider can use these methods, most particularly the third one, to provide an API that can be accessed by other origins to manipulate the user's address book.	 連絡先プロバイダは、これらのメソッド、特に3番目のメソッドを使用して、ユーザーのアドレス帳を操作するために他のオリジンからアクセスできるAPIを提供できます。	web-messaging
For example, it could respond to a message " add-contact Guillaume Tell <tell@pomme.example.net> " by adding the given person and email address to the user's address book.	たとえば、次のメッセージに応答できます。	web-messaging
To avoid any site on the web being able to manipulate the user's contacts, the contacts provider might only allow certain trusted sites, such as the social site, to do this.	連絡先の追加Guillaume Tell<tell@pomme.example.net> 」と入力すると、指定したユーザーと電子メールアドレスがユーザーのアドレス帳に追加されます。	web-messaging
Now suppose the game wanted to add a contact to the user's address book, and that the social site was willing to allow it to do so on its behalf, essentially "sharing" the trust that the contacts provider had with the social site.	 Web上のサイトがユーザーの連絡先を操作できないようにするために、連絡先プロバイダは、ソーシャルサイトなどの特定の信頼済みサイトに対してのみ、この操作を許可する場合があります。	web-messaging
There are several ways it could do this; most simply, it could just proxy messages between the game site and the contacts site.	 ここで、ゲームがユーザーのアドレス帳に連絡先を追加しようとし、ソーシャルサイトがそれを許可し、基本的に連絡先プロバイダがソーシャルサイトと持っていた信頼を「共有」したとします。	web-messaging
However, this solution has a number of difficulties: it requires the social site to either completely trust the game site not to abuse the privilege, or it requires that the social site verify each request to make sure it's not a request that it doesn't want to allow (such as adding multiple contacts, reading the contacts, or deleting them); it also requires some additional complexity if there's ever the possibility of multiple games simultaneously trying to interact with the contacts provider.	これにはいくつかの方法があります。 最も簡単には、ゲームサイトと連絡先サイト間のメッセージをプロキシすることができます。	web-messaging
Using message channels and MessagePort objects, however, all of these problems can go away.	ただし、このソリューションにはいくつかの困難があります。	web-messaging
When the game tells the social site that it wants to add a contact, the social site can ask the contacts provider not for it to add a contact, but for the capability to add a single contact.	特権を悪用しないようにゲームサイトを完全に信頼するか、ソーシャルサイトが各要求を検証して、許可したくない要求ではないことを確認する必要があります(複数の連絡先を追加する、連絡先を読み取る、それらを削除するなど)。 また、複数のゲームが連絡先プロバイダと同時に対話しようとする可能性がある場合には、さらに複雑さが必要になります。 	web-messaging
The contacts provider then creates a pair of MessagePort objects, and sends one of them back to the social site, who forwards it on to the game.	メッセージチャネルとの使用 MessagePort ただし、これらの問題はすべて解消されます。	web-messaging
The game and the contacts provider then have a direct connection, and the contacts provider knows to only honor a single "add contact" request, nothing else.	ゲームがソーシャルサイトに連絡先を追加したいと伝えた場合、ソーシャルサイトは連絡先プロバイダに対して、連絡先を追加するように依頼するのではなく 能力 をクリックして1つの連絡先を追加します。	web-messaging
In other words, the game has been granted the capability to add a single contact.	連絡先プロバイダは次に MessagePort すると、ゲームと連絡先プロバイダーは直接接続され、連絡先プロバイダーは「連絡先の追加」要求を1つだけ受け付けることを知っています。	web-messaging
9.4.1.3 Ports as the basis of abstracting out service implementations Continuing the example from the previous section, consider the contacts provider in particular.	つまり、ゲームには1つの連絡先を追加する機能が付与されています。 	web-messaging
While an initial implementation might have simply used XMLHttpRequest objects in the service's iframe , an evolution of the service might instead want to use a shared worker with a single WebSocket connection.	9.4.1.3サービス実装を抽象化する基礎としてのポート	web-messaging
If the initial design used MessagePort objects to grant capabilities, or even just to allow multiple simultaneous independent sessions, the service implementation can switch from the XMLHttpRequest s-in-each- iframe model to the shared- WebSocket model without changing the API at all: the ports on the service provider side can all be forwarded to the shared worker without it affecting the users of the API in the slightest.	前のセクションの例を続けて、特に連絡先プロバイダについて考えてみましょう。	web-messaging
9.4.2 Message channels	初期の実装では XML Http要求 サービス内のオブジェクト iframe[イメージフレーム] サービスの進化により、代わりに共有労働者単一の Webソケット 接続。	web-messaging
	 最初の設計で MessagePort オブジェクトを使用して機能を付与することも、複数の独立したセッションを同時に許可することもできます。 XML Http要求 s-各- iframe[イメージフレーム] モデルを共有- Webソケット サービス・プロバイダー側のポートはすべて、APIのユーザーに影響を与えることなく、共有ワーカーに転送することができます。  	web-messaging
	9.4.2メッセージチャネル	web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
channel = new MessageChannel()		web-messaging
Returns a new MessageChannel object with two new MessagePort objects.	水路 =新規 MessageChannel()年()月	web-messaging
channel . port1	新しい MessageChannel 2つの新しいオブジェクト MessagePort オブジェクト。 	web-messaging
Returns the first MessagePort object. channel . port2	水路 です。	web-messaging
	ポート1 最初の MessagePort オブジェクト。	web-messaging
	水路 です。	web-messaging
Returns the second MessagePort object.	ポート2	web-messaging
	2番目の MessagePort オブジェクト。	web-messaging
9.4.3 Message ports ✔ MDN		web-messaging
	9.4.3メッセージポート	web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
Each channel has two message ports.		web-messaging
		web-messaging
	各チャネルには2つのメッセージポートがあります。	web-messaging
Data sent through one port is received by the other port, and vice versa.	一方のポートを介して送信されたデータは他方のポートで受信され、その逆も同様です。	web-messaging
port . postMessage( message [, transfer ]) port . postMessage( message [, { transfer }])	 ポート です。	web-messaging
Posts a message through the channel.	ポストメッセージ(の メッセージ [ 移送 ]) ポート です。	web-messaging
	ポストメッセージ(の メッセージ [、{移送}])	web-messaging
Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.	チャネルを介してメッセージを投稿します。	web-messaging
Throws a " DataCloneError " DOMException if transfer contains duplicate objects or port , or if message could not be cloned.	にリストされているオブジェクト 移送 コピーされるだけでなく転送されるため、送信側では使用できなくなります。 	web-messaging
port . start()	をスローします。 」 DataCloneError 」 DOM例外 もし 移送 に重複するオブジェクトが含まれている ポート 、または メッセージ クローンを作成できませんでした。 	web-messaging
	ポート です。	web-messaging
Begins dispatching messages received on the port. port . close()	スタート()年()月	web-messaging
Disconnects the port, so that it is no longer active.	ポートで受信したメッセージのディスパッチを開始します。 ポート です。 閉じる()年()月	web-messaging
9.4.4 Broadcasting to many ports	ポートの接続を解除して、アクティブでない状態にします。	web-messaging
	9.4.4多数のポートへのブロードキャスト	web-messaging
Broadcasting to many ports is in principle relatively simple: keep an array of MessagePort objects to send messages to, and iterate through the array to send a message.	多数のポートへのブロードキャストは、原則として比較的簡単です。	web-messaging
	MessagePort オブジェクトにメッセージを送信し、配列を繰り返し処理してメッセージを送信します。	web-messaging
However, this has one rather unfortunate effect: it prevents the ports from being garbage collected, even if the other side has gone away.	ただし、これにはかなり残念な効果があります。	web-messaging
To avoid this problem, implement a simple protocol whereby the other side acknowledges it still exists.	それは、たとえ相手がいなくなったとしても、ポートがガベージコレクションされるのを防ぐことです。	web-messaging
If it doesn't do so after a certain amount of time, assume it's gone, close the MessagePort object, and let it be garbage collected.	この問題を回避するには、相手がまだ存在することを確認する単純なプロトコルを実装します。	web-messaging
9.4.5 Ports and garbage collection	一定の時間が経過してもそうならない場合は、それがなくなったと仮定して MessagePort これをガーベッジ・コレクションの対象にします。 	web-messaging
	9.4.5ポートとガベージコレクション	web-messaging
Authors are strongly encouraged to explicitly close MessagePort objects to disentangle them, so that their resources can be recollected.	作成者は明示的に閉じることを強くお勧めします。	web-messaging
Creating many MessagePort objects and discarding them without closing them can lead to high transient memory usage since garbage collection is not necessarily performed promptly, especially for MessagePort s where garbage collection can involve cross-process coordination.	MessagePort それらのリソースを再収集できるように、それらを分離するためのオブジェクト。	web-messaging
	MessagePort オブジェクトを閉じずに破棄すると、一時的にメモリの使用率が高くなる可能性があります。 これは、ガーベッジコレクションが必ずしも迅速に実行されないためです。	web-messaging
9.5 Broadcasting to other browsing contexts	MessagePort ここで、ガーベッジ・コレクションにはプロセス間の調整が必要です。 	web-messaging
	9.5 他の閲覧コンテキストへのブロードキャスト	web-messaging
		web-messaging
		web-messaging
Pages on a single origin opened by the same user in the same user agent but in different unrelated browsing contexts sometimes need to send notifications to each other, for example "hey, the user logged in over here, check your credentials again".		web-messaging
For elaborate cases, e.g. to manage locking of shared state, to manage synchronization of resources between a server and multiple local clients, to share a WebSocket connection with a remote host, and so forth, shared workers are the most appropriate solution.	 単一ページ 原点同じユーザーが同じユーザーエージェントで開いているが、関連のない別のユーザーエージェントで開いているコンテキストの参照がお互いに通知を送信する必要がある場合があります。 たとえば、「Hey,the user logged in over here,check your credentials again」などです。 	web-messaging
For simple cases, though, where a shared worker would be an unreasonable overhead, authors can use the simple channel-based broadcast mechanism described in this section.	たとえば、共有状態のロックを管理したり、サーバと複数のローカルクライアント間のリソースの同期を管理したり Webソケット リモートホストとの接続など共有ワーカーが最も適切な解決策です。 	web-messaging
broadcastChannel = new BroadcastChannel( name )	ただし、共有ワーカーが不合理なオーバーヘッドとなるような単純な場合には、このセクションで説明する単純なチャネルベースのブロードキャストメカニズムを使用できます。 	web-messaging
Returns a new BroadcastChannel object via which messages for the given channel name can be sent and received.	broadcastChannel =新規 BroadcastChannel(の 名 )を	web-messaging
broadcastChannel . name	新しい BroadcastChannel 指定されたチャネル名のメッセージを送受信するためのオブジェクト。 	web-messaging
Returns the channel name (as passed to the constructor). broadcastChannel . postMessage( message )	broadcastChannel です。	web-messaging
	名 (コンストラクタに渡された)チャネル名を返します。 broadcastChannel です。	web-messaging
	ポストメッセージ(の メッセージ )を	web-messaging
Sends the given message to other BroadcastChannel objects set up for this channel.	指定されたメッセージを他のユーザに送信します。	web-messaging
Messages can be structured objects, e.g. nested objects and arrays.	BroadcastChannel このチャネルに設定されたオブジェクト。	web-messaging
broadcastChannel . close()	メッセージは、ネストされたオブジェクトや配列などの構造化されたオブジェクトである場合があります。 	web-messaging
	broadcastChannel です。	web-messaging
	閉じる()年()月	web-messaging
Closes the BroadcastChannel object, opening it up to garbage collection.	ダイアログを閉じます。	web-messaging
	BroadcastChannel オブジェクトをガベージコレクションに対してオープンにします。 	web-messaging
Authors are strongly encouraged to explicitly close BroadcastChannel objects when they are no longer needed, so that they can be garbage collected.	作成者は明示的に閉じることを強くお勧めします。	web-messaging
Creating many BroadcastChannel objects and discarding them while leaving them with an event listener and without closing them can lead to an apparent memory leak, since the objects will continue to live for as long as they have an event listener (or until their page or worker is closed).	BroadcastChannel 不要になったオブジェクトをガベージコレクションできるようにします。	web-messaging
	BroadcastChannel イベントリスナーがある限り(またはページまたはワーカーが閉じられるまで)オブジェクトは存続し続けるため、オブジェクトを閉じずにイベントリスナーに残したまま破棄すると、明らかにメモリリークが発生する可能性があります。 	web-messaging
Suppose a page wants to know when the user logs out, even when the user does so from another tab at the same site:	ユーザーが同じサイトの別のタブからログアウトした場合でも、そのユーザーがいつログアウトしたかをページで確認するとします。	web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
		web-messaging
