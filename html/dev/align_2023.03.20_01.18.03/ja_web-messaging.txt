HTML:The Living Standard(HTML:生活水準)
Web開発者向けエディション-最終更新日 2023年3月17日
←9.2サーバ送信イベント-目次-Webワーカー10名→
9.3ドキュメント間のメッセージング
9.3.1はじめに
9.3.2セキュリティ
9.3.3メッセージの投稿
9.4チャネル・メッセージング
9.4.1はじめに
9.4.1.1例
9.4.1.2Web上のオブジェクト機能モデルの基礎としてのポート
9.4.1.3サービス実装を抽象化する基礎としてのポート
9.4.2メッセージチャネル
9.4.3メッセージポート
9.4.4多数のポートへのブロードキャスト
9.4.5ポートとガベージコレクション
9.5他の閲覧コンテキストへのブロードキャスト 9.3 ドキュメント間のメッセージング
││││ MDN(モデム)
ウィンドウ/ポストメッセージ
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 3以上 サファリ 4以上 クロム 1以上 オペラ 9.5以上 エッジ(Edge) 79以上 エッジ(旧形式) 12以上 Internet Explorerの場合 10以上 FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid ≤37+ サムスン・インターネット は?
 オペラ・アンドロイド 10.1以上
Webブラウザは、セキュリティおよびプライバシー上の理由から、異なるドメインのドキュメントが互いに影響を及ぼすことを防止します。
つまり、クロスサイトスクリプティングは禁止されています。

これは重要なセキュリティ機能ですが、異なるドメインのページが敵対的でない場合でも、それらのページが通信するのを防ぎます。
このセクションでは、クロスサイト・スクリプティング攻撃を可能にしないように設計された方法で、ソース・ドメインに関係なくドキュメントが相互に通信できるようにするメッセージング・システムを紹介します。

の postMessage()[ポストメッセージ] APIは トラッキングベクトルです。

9.3.1はじめに
たとえば、ドキュメントAに iframe[イメージフレーム] 文書Bを含む要素、および文書A内のスクリプト postMessage()[ポストメッセージ] の 窓 オブジェクトの場合、そのオブジェクトに対してメッセージイベントが発生し 窓 ドキュメントAのスクリプトは次のようになります。

変数 オ =<数値> 文書 です。
 getElementsByTagName(タグ名別要素の取得) (の 'iframe'を指定します。
 )[ 0 ] オ です。
 コンテンツウィンドウ です。
 ポストメッセージ (の 「ハローワールド」 「https://b.example.org/」 )
受信イベントのイベント・ハンドラーを登録するには、次のように記述します。
 addEventListener()[イベントリスナーの追加] (または同様のメカニズム)。
たとえば、ドキュメントBのスクリプトは次のようになります。

窓 です。
 イベントリスナーの追加 (の 'メッセージ' 受信機 偽 ) 機能 受信機 (の eキー )を {を もし (の eキー です。
 原点 == 'https://example.com'を参照してください。
 )を {を もし (の eキー です。
 資料 == 「ハローワールド」 )を {を eキー です。
 源泉 です。
 ポストメッセージ (の 「こんにちは」 eキー です。
 原点 ) }をクリックし それ以外 {を 警戒 (の eキー です。
 資料 ) }をクリックし }をクリックし }をクリックし
このスクリプトは、最初にドメインが予期されたドメインであるかどうかをチェックし、次にメッセージを確認します。
メッセージはユーザーに表示されるか、最初にメッセージを送信したドキュメントにメッセージを返信することで応答します。

9.3.2セキュリティ
このAPIを使用するには、悪意のあるエンティティが自分の目的のためにサイトを悪用することからユーザを保護するために、特別な注意が必要です。

作成者は 原点 属性を使用して、メッセージを受信するドメインからのメッセージのみが受け入れられるようにします。
そうしないと、作成者のメッセージ処理コードのバグが悪意のあるサイトによって悪用される可能性があります。

また、製造販売後調査において 原点 属性を使用する場合、作成者は、問題のデータが想定された形式であることも確認する必要があります。
そうでない場合、イベントのソースがクロスサイトスクリプティングの欠陥を使用して攻撃された場合 postMessage()[ポストメッセージ] メソッドを使用すると、攻撃がレシーバに伝播される可能性があります。

作成者は ターゲット原点 秘密情報を含むメッセージ内の引き数。
それ以外の場合は、メッセージが意図された受信者にのみ配信されることを保証する方法はない。

あらゆる発信元からのメッセージを受け入れる作成者は、サービス拒否攻撃のリスクを考慮することが推奨されます。
攻撃者は大量のメッセージを送信する可能性があります。
受信ページが高価な計算を実行したり、そのようなメッセージごとにネットワークトラフィックを送信させたりすると、攻撃者のメッセージがサービス拒否攻撃に増幅される可能性があります。
作成者は、このような攻撃を非実用的にするために、レート制限(1分あたり特定の数のメッセージのみを受け入れる)を使用することが推奨されます。

9.3.3メッセージの投稿
窓 です。
 ポストメッセージ(の メッセージ [ オプション ])
指定されたウィンドウにメッセージをポストします。
メッセージは、ネストされたオブジェクトや配列などの構造化オブジェクトである場合があり、JavaScript値(文字列、数値 日付(Date) オブジェクトなど)、および次のような特定のデータオブジェクトを含むことができます。
 ファイル(File) ブロブ(Blob) ファイルリスト 、および アレイバッファ オブジェクト。

に一覧表示されるオブジェクト 移送 メンバー オプション コピーされるだけでなく転送されるため、送信側では使用できなくなります。

ターゲット原点は ターゲット原点 メンバー オプション 指定しない場合は、デフォルトの" /(該当日本語 "。
このデフォルトでは、メッセージは同一送信元ターゲットだけに制限されます。

ターゲットウィンドウのオリジンが指定されたターゲットオリジンと一致しない場合、情報の漏洩を回避するためにメッセージは破棄されます。
オリジンに関係なくターゲットにメッセージを送信するには、ターゲットオリジンを ※印 "と入力します。

をスローします。
 」 DataCloneError 」 DOM例外 もし 移送 配列に重複するオブジェクトが含まれています。
 メッセージ クローンを作成できませんでした。

窓 です。
ポストメッセージ(の メッセージ ターゲット原点 [ 移送 ])
これは postMessage()[ポストメッセージ] ここで、ターゲット原点はパラメータとして指定されます。
 window.postMessage(メッセージ,ターゲット,転送) は、次と同じです。
 window.postMessage(メッセージ,{targetOrigin,転送}) です。

にメッセージを投稿するとき 窓 の コンテキストの参照新しい 文書 は、メッセージが意図した受信者を受信しない結果になる可能性があります。
 コンテキストの参照メッセージのリスナを設定する時間が必要です。
したがって、たとえば、メッセージが 窓 新しく作成された子の iframe[イメージフレーム] 、作成者は子を持つことをお勧めします 文書 メッセージを受信する準備ができたことを知らせるメッセージを親に投稿し、親はこのメッセージを待ってからメッセージの投稿を開始します。

9.4 チャネル・メッセージング
││││ MDN(モデム)
チャネル_メッセージング_API
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 41以上 サファリ 5以上 クロム 1以上 オペラ 10.6以上 エッジ(Edge) 79以上 エッジ(旧形式) 12以上 Internet Explorerの場合 10以上 FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド 11以上
要素、メインドキュメントと1つの<iframe>、またはSharedWorkerを介した2つのドキュメント)に添付された異なる閲覧コンテキストで実行される2つの個別のスクリプトが直接通信し、両端にポートがある双方向チャネル(またはパイプ)を介して互いにメッセージを渡すことができます。"
>チャネル・メッセージングAPI/チャネル・メッセージングの使用
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 41以上 サファリ 5以上 クロム 1以上 オペラ 10.6以上 エッジ(Edge) 79以上 エッジ(旧形式) 12以上 Internet Explorerの場合 10以上 FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド 11以上
9.4.1はじめに
コードの独立した部分を有効にする(例えばコンテキストの参照)を使用すると、作成者はチャネルメッセージングです。

このメカニズムの通信チャネルは、両端にポートを持つ2方向パイプとして実装されます。
一方のポートで送信されたメッセージは他方のポートに配信され、その逆も同様です。
メッセージはDOMイベントとして配信され、実行を中断またはブロックすることはありませんタスクです。

接続(2つの「もつれた」ポート)を作成するには MessageChannel() コンストラクタは以下のように呼ばれる。

変数 水路 =<数値> 新しい MessageChannel x
ポートの1つはローカルポートとして保持され、もう1つのポートはリモートコードに送信されます。
たとえば postMessage()[ポストメッセージ] (該当日本語なし
その他のウィンドウ です。
 ポストメッセージ (の 'こんにちは' 'https://example.com'を参照してください。
 [を 水路 です。
 ポート2 ])
メッセージを送信するには postMessage()[ポストメッセージ] メソッドが使用されます。

水路 です。
 ポート1 です。
 ポストメッセージ (の 'こんにちは' )
メッセージを受信するために、人は聞く メッセージ イベント:
水路 です。
 ポート1 です。
 オンメッセージ =<数値> ハンドルメッセージ 機能 ハンドルメッセージ (の 事件 )を {を //メッセージはevent.dataにあります //.//.// }をクリックし
ポートで送信されるデータは、構造化されたデータである可能性があります。
たとえば、ここでは文字列の配列が MessagePort (該当日本語なし
ポート1 です。
 ポストメッセージ ([ 'こんにちは' 'ワールド' ]) 9.4.1.1例
この例では、2つのJavaScriptライブラリが MessagePort これにより、ライブラリを後で別のフレームでホストしたり ワーカー APIを変更する必要はありません。

<<数値> スクリプト ソース =<数値> "contacts.jsの場合" ></ スクリプト > <!
--contactsオブジェクトを公開--> <<数値> スクリプト ソース =<数値> "メール作成.js" ></ スクリプト > <!
--コンポーザオブジェクトを公開--> <<数値> スクリプト > 変数 水路 =<数値> 新しい MessageChannel x 作曲家 です。
 addContactsProvider (の 水路 です。
 ポート1 ) 連絡先 です。
 registerConsumer (の 水路 です。
 ポート2 ) </ スクリプト >
「addContactsProvider()」関数の実装は次のようになります。

機能 addContactsProvider (の ポート )を {を ポート です。
 オンメッセージ =<数値> 機能 (の 事件 )を {を スイッチ (の 事件 です。
 資料 です。
 メッセージタイプ )を {を 事件 '検索結果' (該当日本語なし handleSearchResult (の 事件 です。
 資料 です。
 結果 ) ブレーク 事件 '検索完了' (該当日本語なし handleSearchDone x ブレーク 事件 '検索エラー' (該当日本語なし handleSearchError (の 事件 です。
 資料 です。
 メッセージ ) ブレーク //.//.// }をクリックし } }
または、次のように実装することもできます。

機能 addContactsProvider (の ポート )を {を ポート です。
 イベントリスナーの追加 (の 'メッセージ' 機能 (の 事件 )を {を もし (の 事件 です。
 資料 です。
 メッセージタイプ == '検索結果' )を handleSearchResult (の 事件 です。
 資料 です。
 結果 ) }); ポート です。
 イベントリスナーの追加 (の 'メッセージ' 機能 (の 事件 )を {を もし (の 事件 です。
 資料 です。
 メッセージタイプ == '検索完了' )を handleSearchDone x }); ポート です。
 イベントリスナーの追加 (の 'メッセージ' 機能 (の 事件 )を {を もし (の 事件 です。
 資料 です。
 メッセージタイプ == '検索エラー' )を handleSearchError (の 事件 です。
 資料 です。
 メッセージ ) }); //.//.// ポート です。
 スタート x }
主な違いは addEventListener()[イベントリスナーの追加] 関数start() メソッドも呼び出す必要があります。
 オンメッセージ の呼び出し 関数start() が暗示されます。

の 関数start() メソッドは、明示的に呼び出されても暗黙的に呼び出されても( オンメッセージ )、メッセージのフローを開始します。
メッセージポートに投稿されたメッセージは、スクリプトがハンドラを設定する前に床に落とされないように、最初は一時停止されます。

9.4.1.2Web上のオブジェクト機能モデルの基礎としてのポート
ポートは、システム内の他のアクターに対して(オブジェクト-機能モデルの意味で)制限された機能を公開する方法と見なすことができます。
これは、ポートが特定のオリジン内の便利なモデルとしてのみ使用される弱い機能システムか、ポートが1つのオリジンによって提供される強い機能モデルのいずれかです。
 提供者 唯一のメカニズムとして 消費者 変化をもたらすか、情報を得ることができる 提供者 です。

たとえば、ソーシャルWebサイトが iframe[イメージフレーム] ユーザーのEメール連絡先プロバイダ(第2の発信元からのアドレス帳サイト) iframe[イメージフレーム] ゲーム(第3の起源から)。
外部のソーシャルサイトと2番目のゲーム iframe[イメージフレーム] 1番目の iframe[イメージフレーム] ;これらを一緒に使用すると、次のことだけが
ナビゲートと iframe[イメージフレーム] 新しい ≪URLURLemdwなど)。
 ≪URLURLemdwしかし破片が発生し 窓 領域の iframe[イメージフレーム] 受信 hashchange イベント。

サイズを変更する iframe[イメージフレーム] が発生し 窓 領域の iframe[イメージフレーム] 受信 リサイズ イベント。

送信 メッセージ イベントを 窓 領域の iframe[イメージフレーム] を使用して window.postMessage()[ウィンドウ.ポストメッセージ] API。

連絡先プロバイダは、これらのメソッド、特に3番目のメソッドを使用して、ユーザーのアドレス帳を操作するために他のオリジンからアクセスできるAPIを提供できます。
たとえば、次のメッセージに応答できます。
 連絡先の追加Guillaume Tell<tell@pomme.example.net> 」と入力すると、指定したユーザーと電子メールアドレスがユーザーのアドレス帳に追加されます。

Web上のサイトがユーザーの連絡先を操作できないようにするために、連絡先プロバイダは、ソーシャルサイトなどの特定の信頼済みサイトに対してのみ、この操作を許可する場合があります。

ここで、ゲームがユーザーのアドレス帳に連絡先を追加しようとし、ソーシャルサイトがそれを許可し、基本的に連絡先プロバイダがソーシャルサイトと持っていた信頼を「共有」したとします。
これにはいくつかの方法があります。
最も簡単には、ゲームサイトと連絡先サイト間のメッセージをプロキシすることができます。
ただし、このソリューションにはいくつかの困難があります。
特権を悪用しないようにゲームサイトを完全に信頼するか、ソーシャルサイトが各要求を検証して、許可したくない要求ではないことを確認する必要があります(複数の連絡先を追加する、連絡先を読み取る、それらを削除するなど)。
また、複数のゲームが連絡先プロバイダと同時に対話しようとする可能性がある場合には、さらに複雑さが必要になります。

メッセージチャネルとの使用 MessagePort ただし、これらの問題はすべて解消されます。
ゲームがソーシャルサイトに連絡先を追加したいと伝えた場合、ソーシャルサイトは連絡先プロバイダに対して、連絡先を追加するように依頼するのではなく 能力 をクリックして1つの連絡先を追加します。
連絡先プロバイダは次に MessagePort すると、ゲームと連絡先プロバイダーは直接接続され、連絡先プロバイダーは「連絡先の追加」要求を1つだけ受け付けることを知っています。
つまり、ゲームには1つの連絡先を追加する機能が付与されています。

9.4.1.3サービス実装を抽象化する基礎としてのポート
前のセクションの例を続けて、特に連絡先プロバイダについて考えてみましょう。
初期の実装では XML Http要求 サービス内のオブジェクト iframe[イメージフレーム] サービスの進化により、代わりに共有労働者単一の Webソケット 接続。

最初の設計で MessagePort オブジェクトを使用して機能を付与することも、複数の独立したセッションを同時に許可することもできます。
 XML Http要求 s-各- iframe[イメージフレーム] モデルを共有- Webソケット サービス・プロバイダー側のポートはすべて、APIのユーザーに影響を与えることなく、共有ワーカーに転送することができます。

9.4.2メッセージチャネル
││││ MDN(モデム)
MessageChannel
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 41以上 サファリ 5以上 クロム 1以上 オペラ 10.6以上 エッジ(Edge) 79以上 エッジ(旧形式) 12以上 Internet Explorerの場合 10以上 FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド 11以上
水路 =新規 MessageChannel()年()月
新しい MessageChannel 2つの新しいオブジェクト MessagePort オブジェクト。

水路 です。
 ポート1
最初の MessagePort オブジェクト。
 水路 です。
 ポート2
2番目の MessagePort オブジェクト。
 9.4.3メッセージポート
││││ MDN(モデム)
MessagePort
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 41以上 サファリ 5以上 クロム 1以上 オペラ 10.6以上 エッジ(Edge) 79以上 エッジ(旧形式) 12以上 Internet Explorerの場合 10以上 FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド 11以上
各チャネルには2つのメッセージポートがあります。
一方のポートを介して送信されたデータは他方のポートで受信され、その逆も同様です。

ポート です。
 ポストメッセージ(の メッセージ [ 移送 ]) ポート です。
 ポストメッセージ(の メッセージ [、{移送}])
チャネルを介してメッセージを投稿します。
にリストされているオブジェクト 移送 コピーされるだけでなく転送されるため、送信側では使用できなくなります。

をスローします。
 」 DataCloneError 」 DOM例外 もし 移送 に重複するオブジェクトが含まれている ポート 、または メッセージ クローンを作成できませんでした。

ポート です。
 スタート()年()月
ポートで受信したメッセージのディスパッチを開始します。
 ポート です。
 閉じる()年()月
ポートの接続を解除して、アクティブでない状態にします。
 9.4.4多数のポートへのブロードキャスト
多数のポートへのブロードキャストは、原則として比較的簡単です。
 MessagePort オブジェクトにメッセージを送信し、配列を繰り返し処理してメッセージを送信します。
ただし、これにはかなり残念な効果があります。
それは、たとえ相手がいなくなったとしても、ポートがガベージコレクションされるのを防ぐことです。
この問題を回避するには、相手がまだ存在することを確認する単純なプロトコルを実装します。
一定の時間が経過してもそうならない場合は、それがなくなったと仮定して MessagePort これをガーベッジ・コレクションの対象にします。

9.4.5ポートとガベージコレクション
作成者は明示的に閉じることを強くお勧めします。
 MessagePort それらのリソースを再収集できるように、それらを分離するためのオブジェクト。
 MessagePort オブジェクトを閉じずに破棄すると、一時的にメモリの使用率が高くなる可能性があります。
これは、ガーベッジコレクションが必ずしも迅速に実行されないためです。
 MessagePort ここで、ガーベッジ・コレクションにはプロセス間の調整が必要です。

9.5 他の閲覧コンテキストへのブロードキャスト
││││ MDN(モデム)
BroadcastChannel
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 38以上 サファリ 15.4以上 クロム 54以上 オペラ は?
 エッジ(Edge) 79以上 エッジ(旧形式) は?
 Internet Explorerの場合 いいえ FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド は?

ブロードキャストチャネルAPI
現在のすべてのエンジンでサポートされています。
 ファイアーフォックス 38以上 サファリ 15.4以上 クロム 54以上 オペラ は?
 エッジ(Edge) 79以上 エッジ(旧形式) は?
 Internet Explorerの場合 いいえ FirefoxのAndroid は?
 SafariのiOS は?
 ChromeのAndroid は?
 WebViewのAndroid は?
 サムスン・インターネット は?
 オペラ・アンドロイド は?

単一ページ 原点同じユーザーが同じユーザーエージェントで開いているが、関連のない別のユーザーエージェントで開いているコンテキストの参照がお互いに通知を送信する必要がある場合があります。
たとえば、「Hey,the user logged in over here,check your credentials again」などです。

たとえば、共有状態のロックを管理したり、サーバと複数のローカルクライアント間のリソースの同期を管理したり Webソケット リモートホストとの接続など共有ワーカーが最も適切な解決策です。

ただし、共有ワーカーが不合理なオーバーヘッドとなるような単純な場合には、このセクションで説明する単純なチャネルベースのブロードキャストメカニズムを使用できます。

broadcastChannel =新規 BroadcastChannel(の 名 )を
新しい BroadcastChannel 指定されたチャネル名のメッセージを送受信するためのオブジェクト。

broadcastChannel です。
 名
(コンストラクタに渡された)チャネル名を返します。
 broadcastChannel です。
 ポストメッセージ(の メッセージ )を
指定されたメッセージを他のユーザに送信します。
 BroadcastChannel このチャネルに設定されたオブジェクト。
メッセージは、ネストされたオブジェクトや配列などの構造化されたオブジェクトである場合があります。

broadcastChannel です。
 閉じる()年()月
ダイアログを閉じます。
 BroadcastChannel オブジェクトをガベージコレクションに対してオープンにします。

作成者は明示的に閉じることを強くお勧めします。
 BroadcastChannel 不要になったオブジェクトをガベージコレクションできるようにします。
 BroadcastChannel イベントリスナーがある限り(またはページまたはワーカーが閉じられるまで)オブジェクトは存続し続けるため、オブジェクトを閉じずにイベントリスナーに残したまま破棄すると、明らかにメモリリークが発生する可能性があります。

ユーザーが同じサイトの別のタブからログアウトした場合でも、そのユーザーがいつログアウトしたかをページで確認するとします。

変数 authChannel =<数値> 新しい BroadcastChannel (の '認証' ) authChannel です。
 オンメッセージ =<数値> 機能 (の 事件 )を {を もし (の 事件 です。
 資料 == 'ログアウト' )を showLogout x }をクリックし 機能 logoutRequested ()年()月 {を //ユーザがログアウトを要求したときに呼び出されます。
 doLogout x showLogout x authChannel です。
 ポストメッセージ (の 'ログアウト' ) }をクリックし 機能 doLogout ()年()月 {を //実際にユーザをログアウトする(cookieをクリアするなど) //.//.// }をクリックし 機能 showLogout ()年()月 {を //UIを更新してログアウトされたことを示す //.//.// }をクリックし
←9.2サーバ送信イベント-目次-Webワーカー10名→
